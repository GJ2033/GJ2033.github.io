<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>接口</title>
      <link href="2021/011816112.html"/>
      <url>2021/011816112.html</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h2><h3 id="6-1-1-接口概念"><a href="#6-1-1-接口概念" class="headerlink" title="6.1.1 接口概念"></a>6.1.1 接口概念</h3><p>接口不是类，是对类的一组需求描述。Array类中的sort方法可以对对象数组进行排序，但要求对象所属的类必须实现Comparable接口。<br>下面是Comparable接口的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Comparable&#123;    int compareTo(Object other);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，任何实现Comparable接口的类都需要包含compareTo方法，并且这个方法的参数是一个Object对象，返回一个整形数值。</p><p>接口中的所有方法自动声明为public，因此接口中的方法无需提供关键字public。<br>接口中可以声明多个方法，可以定义常量，但绝对不能含有实例域。提供实例域和方法实现的任务应该由实现接口的类来完成。可以暂时将接口看成没有实例域的抽象类。</p><p>为了让类实现一个接口，包含两个步骤：</p><ul><li>1.将类声明为实现某个接口</li><li>2.对接口中的所有方法进行定义</li></ul><p>使用implements关键字  </p><p><code>class Employee implements Comparable</code></p><p>Employee类中应提供compareTo方法的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee implements Comparable&#123;    public int compareTo(Object otherObject)    &#123;        Employee other &#x3D; (Employee) otherObject;        return Double.compare(salary, other.salary);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为何不在类中直接定义compareTo方法，原因是在编译时会检查对象是否实现了某个方法。只要Employee是一个Comparable的，其就一定实现了compareTo方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">部分APIjava.lang.Comparable&lt;T&gt;int compareTo(T other)java.util.Arraysstatic void sort(Object[] a)java.lang.Integerstatic int compare(int x, int y)java.lang.Doublestatic int compare(double x, double y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-2-接口的特性"><a href="#6-1-2-接口的特性" class="headerlink" title="6.1.2 接口的特性"></a>6.1.2 接口的特性</h3><p>接口不是类，不能用new运算符实例化一个接口。</p><p>不能构造接口的对象，但可以声明一个接口的变量。<br><code>Comparable x;</code></p><p>接口变量必须引用实现了接口的类对象：</p><p><code>x = new Employee(...);</code></p><p>使用instanceof检查一个对象是否实现了某个特定的接口。<br><code>if (anObject instanceof Comparable) &#123;...&#125;</code></p><p>与可以建立类的继承关系一样，接口也可以被扩展。假设有一个Moveable的接口：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Moveable&#123;    void move(double x, double y);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以它为基础扩展一个Powered的接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Powered extends Moveable&#123;    double milesPerGallon();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>虽然接口中不能包含实例域或静态方法，但却可以包含常量。例如：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Powered extends Moveable&#123;    double milesPerGallon();    double SPEED_LIMIT &#x3D; 95;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口中的域被自动设定为public static final。</p><h3 id="6-1-3-接口与抽象类"><a href="#6-1-3-接口与抽象类" class="headerlink" title="6.1.3 接口与抽象类"></a>6.1.3 接口与抽象类</h3><p>为何不适用抽象类实现上文的Comparable方法呢，因为java支持单继承，每个类只能扩展一个类，假设Employee继承了Person，就不能再扩展第二个类了，但是却可以实现多个接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee extends Person, Comparable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-1-4-静态方法"><a href="#6-1-4-静态方法" class="headerlink" title="6.1.4 静态方法"></a>6.1.4 静态方法</h3><p>从Java SE8开始，允许在接口中添加静态方法，但通常做法是<br>将静态方法放在伴随类中。在标准库中，有成对出现的接口和实用工具类，如Collection/Collections或Path/Paths。</p><p>在Paths类中，只包含两个工厂方法。由一个字符序列构造一个文件或目录的路劲，如Path.get(“jdk1.8.0”, “jre”, “bin”)。在Java SE8中，可以为Path接口添加以下方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Path&#123;    public static Path get(String first, String... more)&#123;        return FileSystems.getDefault().getPath(first, more);    &#125;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，Paths类就不是必要的了。在实现你自己的接口时，不再需要为实用工具方法另外提供一个伴随类。</p><h3 id="6-1-5-默认方法"><a href="#6-1-5-默认方法" class="headerlink" title="6.1.5 默认方法"></a>6.1.5 默认方法</h3><p>可以为接口提供一个默认实现。必须用default修饰符标记这样一个方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">piblic interface Comparable&lt;T&gt;&#123;    default int compareTo(T other)&#123;return 0;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>默认方法的应用：</p><p>如希望在发生鼠标点击事件的时得到通知，就要实现一个包含5个方法的接口，在大多数情况下，只需要关心其中的1、2个事件类型。在Java SE8中，可以把所有方法声明为默认方法，这些默认方法什么也不做。实现这个接口时只需要覆盖那些自己关系的方法就行了。默认方法可以调用任何其他方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface MouseListener&#123;    default void mouseClicked(MouseEvent event)&#123;&#125;    default void mousePressed(MouseEvent event)&#123;&#125;    default void mouseReleased(MouseEvent event)&#123;&#125;    default void mouseEntered(MouseEvent event)&#123;&#125;    default void mouseExited(MouseEvent event)&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-6-解决默认方法冲突"><a href="#6-1-6-解决默认方法冲突" class="headerlink" title="6.1.6 解决默认方法冲突"></a>6.1.6 解决默认方法冲突</h3><p>如果在一个接口中定义了一个默认方法，然后又在超类或另一个接口中定义了同样的方法，规则如下：</p><ol><li>超类优先，此时同名同参数的默认方法被忽略。</li><li>接口冲突，如果一个超接口提供了一个默认方法，另一个接口提供了同名同参数类型的方法，则必须覆盖这个方法解决冲突。</li></ol><p>考虑一个包含getName方法的接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Named&#123;    default String getName()&#123;        return getClass.getName() + &quot;_&quot; + hashCode();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个类同时实现了这两个接口：<br><code>class Student implements Person, Named&#123;...&#125;</code></p><p>Java编译器将报错，让程序员解决这个二义性。选择两个冲突方法中的一个。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Student implements Person, Named&#123;    public String getName()&#123;return Person.super.getName();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是第一种情况，如<code>class Student extends Person implements Named&#123;...&#125;</code></p><p>这种情况下只会考虑超类方法。</p><h2 id="6-2-接口示例"><a href="#6-2-接口示例" class="headerlink" title="6.2 接口示例"></a>6.2 接口示例</h2><p>接口的另外一些使用场景</p><h3 id="6-2-1-接口与回调"><a href="#6-2-1-接口与回调" class="headerlink" title="6.2.1 接口与回调"></a>6.2.1 接口与回调</h3><p>回调是一种常见的设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p><p>Java.swing包有一个Timer类，可以使用它在到达指定时间间隔发出通告。在构造定时器时，需要设置一个一个时间间隔，并告知定时器，当达到时间间隔时需要做哪些操作。</p><p>在Java类库中采用的是面向对象方法。它将某个类的对象传递给定时器，然后定时器调用这个对象的方法。</p><p>定时器需要知道调用哪一个方法，并要求传递的对象所属的类实现了java.awt.event包的ActionListener接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ActionListener&#123;    void actionPerformed(ActionEvent event);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当到达指定的时间，定时器就调用actionPerformed方法。</p><p>如希望每隔10s打印一条信息”At the tone, the time is …”，就应该定义一个实现ActionListener接口的类，然后将需要执行的语句放在actionPerformed方法中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TimePrinter implements ActionListener&#123;    public void actionPerformed(ActionEvent event)    &#123;        System.out.println(&quot;At the tone, the time is &quot; + new Date());    &#125;&#125;ActionListener listener &#x3D; new TimePrinter();Timer t &#x3D; new Timer(10000, listener);t.start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-2-Comparator接口"><a href="#6-2-2-Comparator接口" class="headerlink" title="6.2.2 Comparator接口"></a>6.2.2 Comparator接口</h3><p>Array.sort方法还有第二个版本，有一个数组和一个比较器（comparator）作为参数，比较器是实现了Comparator接口的类的实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Comparator&lt;T&gt;&#123;    int compare(T first, T second);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>要按长度比较字符串，可以定义一个实现Comparator<String>的类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class LengthComparator implements Comparator&lt;String&gt;&#123;    public int compare(String first, String second)&#123;        return first.length() - second.length();    &#125;&#125;&#x2F;&#x2F;对一个数组排序， 需要为Arrays.sort方法传入一个LengthComparator对象String[] firends &#x3D; &#123;&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;&#125;;Array.sort(firends, new LengthComparator());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-3-对象克隆"><a href="#6-2-3-对象克隆" class="headerlink" title="6.2.3 对象克隆"></a>6.2.3 对象克隆</h3><p>本节讨论Cloneable接口，这个接口指示一个类提供了一个安全的clone方法。</p><p>对于一个对象引用的变量创建副本时，它们都是引用的同一个对象，改变一个变量会影响另一个变量。如果希望copy是一个新对象，初始状态一致，但之后它们有各自的状态，这种情况下应该使用clone方法。<br>如果对象中数据域仍然含有对其他对象的引用，那么拷贝得到的是相同子对象的引用，即浅拷贝。</p><p>通常必须子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象。这样类必须<strong>实现Cloneable接口</strong>，并<strong>重新定义clone方法</strong>，指定public访问修饰符。（clone方法在Object类中声明为protected，子类只能调用受保护的clone方法来克隆它自己的对象。必须重新定义clone为public才能允许所有方法克隆对象）</p><p>Employee类深拷贝的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee implements Cloneable&#123;    public Employee clone() throws CloneNotSupportedException    &#123;        &#x2F;&#x2F;call Object.clone        Employee cloned &#x3D; (Employee) super.clone();        &#x2F;&#x2F;clone mutable fields        cloned.hireDay &#x3D; (Date) hireDay.clone();        return cloned;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-3-lambda表达式"><a href="#6-3-lambda表达式" class="headerlink" title="6.3 lambda表达式"></a>6.3 lambda表达式</h2><p>本节学习如何使用lambda表达式采用一种简洁的语法定义代码块，以及如何编写处理lambda表达式的代码。</p><h3 id="6-3-1-lambda表达式的语法"><a href="#6-3-1-lambda表达式的语法" class="headerlink" title="6.3.1 lambda表达式的语法"></a>6.3.1 lambda表达式的语法</h3><p>第一个示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">(String first, String second)     -&gt; first.length() - second.length()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二个示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">(String first, String second) -&gt;    &#123;        if(first.length() &lt; second.length()) return -1;        else if (first.length() &gt; second.length()) return 1;        else return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使lambda表达式没有参数，也要提供空括号：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">() -&gt; &#123;for (int i&#x3D;100; i&gt;&#x3D;0; i--) System.out.println(i);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-3-2-函数式接口"><a href="#6-3-2-函数式接口" class="headerlink" title="6.3.2 函数式接口"></a>6.3.2 函数式接口</h3><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口。</p><p>考虑Arrays.sort方法，它的第二个参数需要一个Comparator实例，Comparator就是只有一个方法的接口，可以提供一个lambda表达式:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Arrays.sort(words,    (first, second) -&gt; first.length() - second.length());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-3-3-方法引用"><a href="#6-3-3-方法引用" class="headerlink" title="6.3.3 方法引用"></a>6.3.3 方法引用</h3><p>假设希望定时器在出现一个定时器事件时就打印这个事件对象，可以调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Timer t &#x3D; new Timer(1000, event -&gt; System.out.println(event));&#x2F;&#x2F;直接把println方法传递给Timer构造器就更好了Timer t &#x3D; new Timer(1000, System.out::println);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表达式System.out::println是一个方法引用，它等价于lambda表达式x-&gt;System.out.println(x)。</p><p>使用::操作符分隔方法名与对象名或类名，只要有3种情况：<br>object::instanceMethod<br>Class::staticMethod<br>Class::instanceMethod<br>前两种情况下，方法引用等价于提供方法参数的lambda表达式。System.out::println等价于x-&gt;System.out.println(x)。类似地，Math.pow等价于(x, y) -&gt; Math.pow(x, y)。</p><p>对于第三种情况，第一个参数会称为方法的目标。例如：String::compareToIgnoreCase等同于(x, y) -&gt; x.compareToIgnoreCase(y)。<br>还可以在方法引用中使用this, super参数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Greeter&#123;    public void greet()    &#123;        System.out.println(&quot;Hello World&quot;);    &#125;&#125;class TimedGreeter extends Greeter&#123;    public void greet()    &#123;        Timer t &#x3D; new Timer(1000, super::great);        t.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TimedGreeter.greet方法开始执行时，会构造一个Timer，它每次定时执行super::great方法。这个方法调用超类的greet方法。</p><h3 id="6-3-4-构造器引用"><a href="#6-3-4-构造器引用" class="headerlink" title="6.3.4 构造器引用"></a>6.3.4 构造器引用</h3><p>构造器引用与方法引用类似，只不过方法名为new。例如Person::new是Person构造器的一个引用。哪一个构造器呢？这取决于上下文。假设你有一个字符串列表，可以把它转换为一个Person对象数组，为此要在各个字符串上调用构造器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList&lt;String&gt; names &#x3D; ...;Stream&lt;Person&gt; stream &#x3D; names.stream().map(Person::new);List&lt;Person&gt; people &#x3D; stream.collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>map方法为每一个列表元素调用Person(String)构造器。</p><p>可以用数组类型建立构造器引用。例如：int[]::new是一个构造器引用，它有一个参数：即数组的长度。这等价于lambda表达式x-&gt;new int[x]。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person[] people &#x3D; stream.toArray(Person[]::new);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>toArray方法调用这个构造器来得到一个正确类型的数组，然后填充这个数组并返回。</p><h3 id="6-3-5-变量作用域"><a href="#6-3-5-变量作用域" class="headerlink" title="6.3.5 变量作用域"></a>6.3.5 变量作用域</h3><p>通常，你可能希望能够在lambda表达式中访问外围方法或类中的变量。考虑下面的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void repeatMessage(String text, int delay)&#123;    ActionListener listener &#x3D; event -&gt;    &#123;        System.out.println(text);        Toolkit.getDefaultToolkit().beep();    &#125;;    new Timer(delay, listener).start();&#125;repeatMessage(&quot;Hello&quot;, 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lambda表达式中的变量text是一个repeatMessage中定义的变量。lambda表达式可以捕获外围作用域中变量的值，这里有一个重要的限制：在lambda表达式中，只能引用值不会改变的变量。因为如果在lambda表达式中改变变量，并发地执行多个动作时就会不安全。如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的。</p><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application()&#123;    public void init()&#123;        ActionListener listener &#x3D; event -&gt;        &#123;            System.out.println(this.toString());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达式this.toString()会调用Application对象的toString方法，而不是ActionListener实例的方法。lambda表达式的作用域嵌套在init方法中，与出现在这个方法中的其他位置一样，lambda表达式的this含义并没有改变。</p><h2 id="6-4-内部类"><a href="#6-4-内部类" class="headerlink" title="6.4 内部类"></a>6.4 内部类</h2><p>内部类是定义在另一个类中的类。使用内部类的几点原因：</p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li><li>内部类可以对同一个包中其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较方便</li></ul><h3 id="6-4-1-使用内部类访问对象状态"><a href="#6-4-1-使用内部类访问对象状态" class="headerlink" title="6.4.1 使用内部类访问对象状态"></a>6.4.1 使用内部类访问对象状态</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TalkingColock&#123;    private int interval;    private boolean beep;    public TalkingClock(int interval, boolean beep)&#123;...&#125;    public void start()&#123;...&#125;    public class TimePrinter implements ActionListener    &#123;        public void actionPerformed(ActionEvent event)        &#123;            System.out.println(&quot;At the tone, the time is &quot;+new Date());            if(beep) Toolkit.getDefaultToolkit().beep();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TimePrinter类没有实例域或名为beep的变量，beep引用了创建TimePrinter的TalkingClock对象的域。内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。内部类的对象总是有一个隐式引用，它指向了创建它的外部类对象。</p><h3 id="6-4-2-内部类的特殊语法规则"><a href="#6-4-2-内部类的特殊语法规则" class="headerlink" title="6.4.2 内部类的特殊语法规则"></a>6.4.2 内部类的特殊语法规则</h3><p>内部类有一个外围类的引用outer。使用外围类的正规语法为：<code>outerClass.this</code>。<br>可以这样编写TimePrinter内部类的actionPerformed方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void actionPerformed(ActionEvent event)&#123;    ...    if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以这样编写内部对象的构造器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; outerObject.new InnerClass(construction parameters)ActionListener listener &#x3D; this.new TimePrinter();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-4-3-静态内部类"><a href="#6-4-3-静态内部类" class="headerlink" title="6.4.3 静态内部类"></a>6.4.3 静态内部类</h3><p>如果使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象，可以将内部类声明为<strong>static</strong>,以便取消产生的引用.</p><p>计算数组中的最大值和最小值的问题:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">double min &#x3D; Double.POSITIVE_INFINITY;double max &#x3D; Double.NEGATIVE_INFINITY;for(double v : values)&#123;    if(min &gt; v) min &#x3D; v;    if(max &lt; v) max &#x3D; v;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法必须返回两个数值,为此可以定义一个包含两个值的类Pair:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Pair&#123;    private double first;    private double second;    public Pair(double f, double s)    &#123;        first &#x3D; f;        second &#x3D; s;    &#125;    public double getFirst() &#123;return first;&#125;    public double getSecond() &#123;return second&#125;;&#125;class ArrayAlg&#123;    public static Pair minmax(double[] values)    &#123;        ...        return new Pair(min, max);    &#125;&#125;Pair p &#x3D; ArrayAlg.minmax(d);System.out.println(p.getFirst());System.out.println(p&#x2F;getSecond());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将Pair定义为ArrayAlg的内部公有类,通过ArrayAlg.Pair访问它:</p><p><code>ArrayAlg.Pair p = ArrayAlg.minmax(d);</code></p><p>与前面的内部类不同,在Pair对象中不需要引用任何其他的对象,可以将这个内部类声明为static:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ArrayAlg&#123;    public static class Pair    &#123;        ...    &#125;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整的程序:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticInnerClass;public class StaticInnerClassTest&#123;    public static void main(String[] args)    &#123;        double[] d &#x3D; new double[20];        for( int i&#x3D;0; i &lt; d.length; i++)            d[i] &#x3D; 100 * Math.random();        ArrayAlg.Pair p &#x3D; ArrayAlg.minmax(d);        System.out.println(&quot;min &#x3D; &quot; + p.getFirst());        System.out.println(&quot;max &#x3D; &quot; + p.getSecond());    &#125;&#125;class ArrayAlg&#123;    public static class pair    &#123;        private double first;        private double second;                public Pair(double f, double s)        &#123;            first &#x3D; f;            second &#x3D; s;        &#125;         public double getFirst()        &#123;            return first;        &#125;        public double getSecond()        &#123;            return second;        &#125;        public static Pair minmax(double[] values)        &#123;            double min &#x3D; Double.POSITIVE_INFINITY;            double max &#x3D; Double.NEGATIVE_INFINITY;            for (double v : values)            &#123;                if(min &gt; v) min &#x3D; v;                if(max &lt; v) max &#x3D; v;            &#125;            return new Pair(min, max);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-代理"><a href="#6-5-代理" class="headerlink" title="6.5 代理"></a>6.5 代理</h2><p>利用代理可以在运行时创建一个实现了一组给定接口的新类.</p><h3 id="6-5-1-何时使用代理"><a href="#6-5-1-何时使用代理" class="headerlink" title="6.5.1 何时使用代理"></a>6.5.1 何时使用代理</h3><p>代理类可以在运行时创建全新的类,这样的代理类能够实现指定的接口,在运行时要提供一个调用处理器(invocation handler).调用处理器是实现了InvocationHandler接口的类对象.在这个接口中只有一个方法:</p><p>Object invoke(Object proxy, Method method, Object[] args)</p><p>无论何时调用代理对象的方法,调用处理器的invoke方法都会被调用,并向其传递Method对象和原始的调用参数.调用处理器需要给出处理调用的方式.</p><h3 id="6-5-2-创建代理对象"><a href="#6-5-2-创建代理对象" class="headerlink" title="6.5.2 创建代理对象"></a>6.5.2 创建代理对象</h3><p>使用Proxy类的newProxyInstance方法,该方法有三个参数:</p><ul><li>类加载器(class loader),可以使用不同的类加载器,目前用null表示默认的类加载器.</li><li>一个Class对象数组,每个元素都是需要实现的接口.</li><li>一个调用处理器.</li></ul><p>示例:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TraceHandler implements InvocationHandler&#123;    private Object target;    public TraceHandler(Object t)    &#123;        target &#x3D; t;    &#125;    public Object invoke(Object proxy, Method m, Object[] args) throws Throwable    &#123;        &#x2F;&#x2F;print method name and parameters        ...        &#x2F;&#x2F;invoke actual method        return m.invoke(target, args);    &#125;&#125;Object value &#x3D; ...;InvocationHandler handler &#x3D; new TraceHandler(value);Class[] interfaces &#x3D; new Class[] &#123;Comparable.class&#125;;Object proxy &#x3D; Proxy.newProxyInstance(null, interfaces, handler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020房价排行榜</title>
      <link href="2021/011016111.html"/>
      <url>2021/011016111.html</url>
      
        <content type="html"><![CDATA[<h1 id="2020年各市房价涨跌情况"><a href="#2020年各市房价涨跌情况" class="headerlink" title="2020年各市房价涨跌情况"></a>2020年各市房价涨跌情况</h1><div style = "position:relative; width: 100%; height:0; padding-bottom:75%;"><iframe src="//player.bilibili.com/player.html?aid=798567192&bvid=BV1Sy4y127GX&cid=280560426&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"style="position:absolute; width:100%; height:100%; left: 0; top: 0;"> </iframe></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java类的继承</title>
      <link href="2020/122316110.html"/>
      <url>2020/122316110.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="5-1类、超类、子类"><a href="#5-1类、超类、子类" class="headerlink" title="5.1类、超类、子类"></a>5.1类、超类、子类</h2><p>Employee类和Manager类，is-a的关系，Employee类称为超类（父类），Manager类称为子类。</p><h3 id="5-1-1-定义子类"><a href="#5-1-1-定义子类" class="headerlink" title="5.1.1 定义子类"></a>5.1.1 定义子类</h3><p>如何定义Manager类呢？<br><strong>关键字extends表示继承</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Manager extends Employee&#123;    添加方法和域&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Manager添加的域bonus,添加一个setBonus方法。  </li><li>Manager类自动继承了Employee类中的方法，还继承了name, salary, hireDay这些域。</li></ul><h3 id="5-1-2-覆盖方法"><a href="#5-1-2-覆盖方法" class="headerlink" title="5.1.2 覆盖方法"></a>5.1.2 覆盖方法</h3><p>父类Employee的getSalary方法对于子类Manager并不适用，定义一个新的方法来覆盖(override)超类中的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public double getSalary()&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如何实现？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public double getSalary() &#123;    return bonus + super.getSalary();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>super.getSalary()</code>语句调用的是Employee类的getSalary方法。<br>子类可以增加域、方法和覆盖超类的方法，但不能删除继承的任何域或方法。<br>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。如果超类方法是public，那么子类方法一定要声明为public。</p><h3 id="5-1-3-子类构造器"><a href="#5-1-3-子类构造器" class="headerlink" title="5.1.3 子类构造器"></a>5.1.3 子类构造器</h3><p>提供一个Manager类的构造器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Manager(String name, double salary, int year, int month, int day) &#123;    super(name, salary, year, month, day);    bonus &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>super(...)</code>是调用超类Employee的构造器。</p><p>Manager类的构造器不能访问Employee类的私有域，必须利用Employee类的构造器对这部分私有域进行初始化，通过super实现对超类构造器的调用。<br><strong>使用super调用构造器的语句必须是子类构造器的第一条语句</strong></p><p><strong>子类没有显示调用超类的构造器，将自动调用超类默认(没有参数)构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显示调用父类构造器，则java编译器将报错。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager boss &#x3D; new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15);boss.setBonus(5000);Employee[] staff &#x3D; new Employee[3];staff[0] &#x3D; boss;staff[1] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);staff[2] &#x3D; new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15);&#x2F;&#x2F;输出每个人的薪水for (Employee e:staff)&#123;    System.out.println(e.getName() + &quot; &quot; + e.getSalary());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>e.getSalary()</code>调用能够确定执行哪个getSalary方法，虽然e声明为Employee类型，但实际上e既可以引用Employee对象，也可以引用Manager类型对象。</p><p><strong>一个对象变量可以指示多个实际类型的现象称为多态。在运行时能够自动地选择调用哪个方法的现象称为动态绑定。</strong></p><h3 id="5-1-4-继承层次"><a href="#5-1-4-继承层次" class="headerlink" title="5.1.4 继承层次"></a>5.1.4 继承层次</h3><p>继承并不限于一个层次，如还可以由Manager类派生出Executive类。一个祖先类可以拥有多个子孙继承链。例如，可以由Employee类派生出子类Programmer或Secretary，它们与Manager类没有任何关系。</p><h3 id="5-1-5-多态"><a href="#5-1-5-多态" class="headerlink" title="5.1.5 多态"></a>5.1.5 多态</h3><p>任何一个Manager对象也是父类Employee类的对象。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee e;e &#x3D; new Employee(...);e &#x3D; new Manager(...);   &#x2F;&#x2F;ok, Manager can be used as well<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager boss &#x3D; new Manager(...);Employee[] staff &#x3D; new Employee[3];staff[0] &#x3D; boss;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>staff[0]和boss引用同一个对象，但staff[0]被看作Employee对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">boss.setBonus();    &#x2F;&#x2F;Okstaff[0].setBonus(5000);    &#x2F;&#x2F;Error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此外，不能将一个父类的引用赋给一个子类的变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager m &#x3D; staff[i];   &#x2F;&#x2F;Error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-1-6-final类和方法"><a href="#5-1-6-final类和方法" class="headerlink" title="5.1.6 final类和方法"></a>5.1.6 final类和方法</h3><p>不允许扩展的类称为final类。假设希望阻止人们定义Executive类的子类，那么可以在定义时使用final修饰符。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class Executive extends Manager&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类中的特定方法也可以被声明为final，子类不能覆盖这个方法。(final类中的所有方法自动称为final方法, 不包括域)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee&#123;    ...    public final String getName()    &#123;        return name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Calendar类中的getTime和setTime方法都声明为final，String类也是final类。</p><h3 id="5-1-7-强制类型转换"><a href="#5-1-7-强制类型转换" class="headerlink" title="5.1.7 强制类型转换"></a>5.1.7 强制类型转换</h3><p>有时候，需要将某个类的对象引用转换为另外一个类的对象引用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager boss &#x3D; (Manager) staff[0];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将一个子类的引用赋给一个超类变量，编译器是允许的，但将一个超类的引用赋给一个子类变量，必须进行类型转换。</p><h3 id="5-1-8-抽象类"><a href="#5-1-8-抽象类" class="headerlink" title="5.1.8 抽象类"></a>5.1.8 抽象类</h3><p>将Employee类的getName方法放在更高层次通用超类Person中。<br>添加一个getDescription方法，返回对一个人的简短描述。</p><blockquote><p>an employee with a salary of $50000</p><p>a student majoring in computer science</p></blockquote><p>Person类不需要具体去实现getDescription方法，只需提供一个接口，在Person类的方法前加一个abstact关键字。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract String getDescription();    &#x2F;&#x2F;no implementation required<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>包含一个或多个抽象方法的类本身必须被声明为抽象的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Person&#123;    ...    public abstract String getDescription();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了抽象方法，抽象类还可以包含具体数据和具体方法，Person类保存了姓名和一个返回姓名的具体方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Person&#123;    private String name;    public Person(String name)    &#123;        this.name &#x3D; name;    &#125;    public abstract String getDescription();    public String getName()    &#123;        return name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>抽象方法充当占位的角色，具体实现在子类中，通过扩展抽象Person类，并实现getDescription方法来定义Student类。由于在Student类中不含有抽象方法，所以不必将这个类声明为抽象的。(类即使不含有抽象方法，也可以被声明为抽象类)<br>__抽象类不能被实例化__。<br><strong>可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</strong><br>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person[] people &#x3D; new Person[2];people[0] &#x3D; new Employee(...);people[1] &#x3D; new Student(...);for(Person p : people)&#123;    p.getDescription();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上部分源代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Test\package test;public class Test&#123;public static void main(String[] args) &#123;Manager boss &#x3D; new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15);boss.setBonus(5000);Employee[] staff &#x3D; new Employee[3];staff[0] &#x3D; boss;staff[1] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);staff[2] &#x3D; new Employee(&quot;Tommy Tester&quot;, 40000, 1990, 3, 15);for(Employee e:staff) &#123;System.out.println(&quot;name&#x3D;&quot; + e.getName() + &quot;,salary&#x3D;&quot; + e.getSalary());&#125;Person[] people &#x3D; new Person[2];people[0] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);people[1] &#x3D; new Student(&quot;Maria Morris&quot;, &quot;computer science&quot;);for (Person p : people) &#123;System.out.println(p.getName() + &quot;, &quot; + p.getDescription());&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person\package test;public abstract class Person &#123;private String name;public Person(String name) &#123;this.name &#x3D; name;&#125;public abstract String getDescription();public String getName() &#123;return name;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Student\package test;public class Student extends Person&#123;private String major;public Student(String name, String major) &#123;super(name);this.major &#x3D; major;&#125;public String getDescription() &#123;return &quot;a student majoring in &quot; + major;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee\package test;import java.time.*;public class Employee extends Person&#123;&#x2F;&#x2F;private String name;private double salary;private LocalDate hireDay;public Employee(String name, double salary, int year, int month, int day) &#123;super(name);&#x2F;&#x2F;this.name &#x3D; name;this.salary &#x3D; salary;this.hireDay &#x3D; LocalDate.of(year, month, day);&#125;public String getDescription() &#123;return String.format(&quot;an employee with a salary of $%.2f&quot;, salary);&#125;&#x2F;&#x2F;public String getName() &#123;&#x2F;&#x2F;return name;&#x2F;&#x2F;&#125;public double getSalary() &#123;return salary;&#125;public LocalDate getHireDay() &#123;return hireDay;&#125;public void raiseSalary(double byPercent) &#123;double raise &#x3D; salary * byPercent &#x2F; 100;salary +&#x3D; raise;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager\package test;public class Manager extends Employee&#123;private double bonus;public Manager(String name, double salary, int year, int month, int day) &#123;super(name, salary, year, month, day);bonus &#x3D; 0;&#125;public double getSalary() &#123;return bonus + super.getSalary();&#125;public void setBonus(double b) &#123;bonus &#x3D; b;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-9-受保护访问"><a href="#5-1-9-受保护访问" class="headerlink" title="5.1.9 受保护访问"></a>5.1.9 受保护访问</h3><p>最好将类中的域标记为*<strong>private**<em>,方法标记为</em></strong>public***,任何声明为private的内容对其他类都是不可见的，子类也不能访问超类的私有域。<br>有些时候，希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为protected。例如，Employee类中的hireDay如果声明为protected，Manager类中的方法就可以直接地访问它。<br>受保护的方法更具有实际意义，如果需要限制某个方法的使用，就可以将它声明为protected。这表明子类得到信任，可以正确使用这个方法，而其他类则不行。<br>Java用于控制可见性的4个访问修饰符：</p><ul><li>仅对本类可见————private</li><li>对所有类可见————public</li><li>对本包和所有子类可见————protected</li><li>对本包可见————默认，不需要修饰符</li></ul><h2 id="5-2-Object：所有类的超类"><a href="#5-2-Object：所有类的超类" class="headerlink" title="5.2 Object：所有类的超类"></a>5.2 Object：所有类的超类</h2><p>Object类是Java中所有类的始祖。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object obj &#x3D; new Employee(...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面介绍Object类中的一些基本类容：</p><h3 id="5-2-1-equals方法"><a href="#5-2-1-equals方法" class="headerlink" title="5.2.1 equals方法"></a>5.2.1 equals方法</h3><p>检测一个对象是否等于另一个对象<br>equals方法的实现机制</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee&#123;    ...    public boolean equals(Object otherObject)    &#123;        if (this &#x3D;&#x3D; otherObject) return true;        if (otherObject &#x3D;&#x3D; null) return false;        if (getClass() !&#x3D; otherObject.getClass()) return false;        return Objects.equals(name, other.name) &amp;&amp; salary &#x3D;&#x3D; other.salary &amp;&amp; Object.equals(hireDay, other.hireDay);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果父类中的域都相等，就需要比较子类中的域。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Manager extends Employee&#123;    ...    public boolean equals(Object otherObject)    &#123;        if (!super.equals(otherObject)) return false;        Manager other &#x3D; (Manager) otherObject;        return bonus &#x3D; other.bonus;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-2-toString方法"><a href="#5-2-2-toString方法" class="headerlink" title="5.2.2 toString方法"></a>5.2.2 toString方法</h3><p>返回表示对象值的字符串<br>Employee类的toString方法的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String toString() &#123;    return getClass().getName()    + &quot;[name&#x3D;&quot; + name    + &quot;,salary&#x3D;&quot; + salary    + &quot;,hireDay&#x3D;&quot; + hireDay    + &quot;]&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Manager类的toString方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Manager extends Employee&#123;    ...    public String toString()    &#123;        return super.toString()          + &quot;[bonus&#x3D;&quot; + bonus          + &quot;]&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h2><p>ArrayList是一个采用类型参数的泛型类，用一对尖括号将类名括起来加在后面，例如ArrayList&lt;Employee&gt;。ArrayList在添加或删除元素时，可以自动调节数组容量。<br>声明一个保存Employee对象的数组列表<br><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</code><br>可以省略右边的类型参数：<br><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;();</code></p><p>使用add方法将元素添加到数组列表中</p><p><code>staff.add(new Employee(&quot;Harry Hacker&quot;, ...));</code></p><p>使用<code>staff.ensureCapacity(100)</code>将分配一个包含100个对象的内部数组，这样在调用100次add，不会重新分配空间。<br>或者，可以把初始容量传递给ArrayList构造器：<br><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100);</code></p><p><code>staff.size()</code>返回数组列表的当前元素数量，等价于数组的a.length功能<br>在确认不会添加新元素时，可以使用trimToSize方法将数组列表的容量调整为当前元素数量所需的存储空间数目。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">部分APIArrayList&lt;E&gt;()构造一个空数组列表ArrayList&lt;E&gt;(int initialCapacity)用指定容量构造一个空数组列表boolean add(E obj)在数组列表的尾端添加一个元素，永远返回trueint size()返回存储在数组列表中元素的数量void ensureCapacity(int capacity)确保数组列表在不重新分配存储空间的情况下能够保存给定数量的元素void trimToSize()将数组列表的存储容量削减至当前尺寸<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-1-访问数组列表元素"><a href="#5-3-1-访问数组列表元素" class="headerlink" title="5.3.1 访问数组列表元素"></a>5.3.1 访问数组列表元素</h3><p>使用get和set方法实现访问和改变数组元素的操作。</p><p><code>staff.set(i, harry);</code></p><p>等价于数组中的a[i] = harry;</p><p>获取数组列表中的元素：</p><p><code>Employee e = staff.get(i);</code></p><p>在某个位置插入或删除元素：</p><p><code>int n = staff.size() / 2; staff.add(n, e); Employee e = staff.remove(n); </code></p><p>数组列表的内容拷贝至数组：toArray方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList&lt;X&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(X);...X[] a &#x3D; new X[list.size()];list.toArray(a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“for each”循环遍历数组列表 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (Employee e:staff)&#123;do something with e;&#125;for (int i&#x3D;0; i &lt; staff.size(); i++)&#123;Employee e &#x3D; staff.get(i);do something with e;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">APIvoid set(int index, E obj)改变指定位置的值参数：index位置(0~size()-1)obj:新的值E get(int index)获得指定位置的元素值void add(int index, E obj)E remove(int index)删除一个元素，返回被删除的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-对象包装器与自动装箱"><a href="#5-4-对象包装器与自动装箱" class="headerlink" title="5.4 对象包装器与自动装箱"></a>5.4 对象包装器与自动装箱</h2><p>假如要将int这样的基本类型转换为对象，所有的基本类型都有一个与之对应的类。Integer类对应的基本类型是int，这种类称为包装器，如：Integer、Long、Float、Double、Short、Byte、Character、Void、Boolean。<br>对象包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，对象包装器类还是final，不能定义它们的子类。</p><p>定义一个整形数组列表：<br><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code>  </p><p><code>list.add(3)</code>将自动变为<code>list.add(Integer.valueOf(3))</code>,这种变换称为自动装箱。</p><p><code>int n = list.get(i)</code>相当于<code>int n = list.get(i).intValue();</code>这种变换为自动拆箱。</p><h2 id="5-5-参数数量可变的方法"><a href="#5-5-参数数量可变的方法" class="headerlink" title="5.5 参数数量可变的方法"></a>5.5 参数数量可变的方法</h2><p>printf就是一个参数数量可变的方法，其定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PrintStream&#123;public PrintStream printf(String fmt, Object... args);&#123;return format(fmt, args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Object…表明这个方法可以接受任意数量的对象,相当于Object[]数组。</p><p><code>System.out.printf(&quot;%d %s&quot;, new Object[] &#123;new Integer(n), &quot;widgets&quot;&#125;);</code></p><p>自定义可变参数数量的方法：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static double max(double... values)&#123;double largest &#x3D; Double.NEGATIVE_INFINITY;for (double v: values) if(v &gt; largest) largest &#x3D; v;return largest;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在调用double m = max(3.1, 40.4, -5)时编译器将<br>new double[] {3.1, 40.4, -5}传递给max方法。</p><h2 id="5-6-反射"><a href="#5-6-反射" class="headerlink" title="5.6 反射"></a>5.6 反射</h2><p>反射机制可以用来：</p><ul><li>在运行时分析类的能力</li><li>在运行时查看对象</li><li>实现通用的数组操作代码</li><li>利用Method对象</li></ul><h3 id="5-6-1-Class类"><a href="#5-6-1-Class类" class="headerlink" title="5.6.1 Class类"></a>5.6.1 Class类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee e;...Class c1 &#x3D; e.getClass();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Object类中的getClass()方法将返回一个Class类型的实例，一个Class对象将表示一个特定类的属性。最常用的Class方法是getName，这个方法返回类的名字。</p><p>e.getClass().getName()</p><p>如果e是一个雇员，将返回Employee，如果e是一个经理，将返回Manager。<br>类在一个包里，包的名字也作为类名的一部分。  </p><p>还可以调用Class类的静态方法forName获得类名对应的Class对象。<br>String className = “java.util.Random”;<br>Class c1 = Class.forName(classname);</p><p>获取Class类对象的第三种方法是：如果T是任意Java类型，T.class将代表匹配的类对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class cl1 &#x3D; Random.class;Class cl2 &#x3D; int.class;Class cl3 &#x3D; Double[].class;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虚拟机为每个类型管理一个Class对象，可以用==运算符实现两个类对象比较打的操作。</p><p><code>if(e.getClass() == Employee.class)</code></p><p>还有一个很有用的方法newInstance(),用来动态地创建一个类的实例。例如：</p><p><code>e.getClass().newInstance()</code></p><p>创建了一个与e相同类型的实例，newInstance方法调用类默认的构造器。</p><p>将forName和newInstance结合起来使用，根据存储在字符串中的类名动态创建一个对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String s &#x3D; &quot;java.util.Random&quot;;Object m &#x3D; Class.forName(s).newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-6-2-捕获异常"><a href="#5-6-2-捕获异常" class="headerlink" title="5.6.2 捕获异常"></a>5.6.2 捕获异常</h3><p>Class.forName可能抛出异常，编译器会要求提供一个处理器。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">try&#123;String name &#x3D; ...;&#x2F;&#x2F;get class nameClass c1 &#x3D; Class.forName(name);&#x2F;&#x2F;might throw exceptiondo something with c1;&#125;catch (Exception e)&#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-3-利用反射分析类的能力"><a href="#5-6-3-利用反射分析类的能力" class="headerlink" title="5.6.3 利用反射分析类的能力"></a>5.6.3 利用反射分析类的能力</h3><p>反射机制可以用来检查类的结构：</p><p>在java.lang.reflect包中有三个类Field、Method、Constructor分别用于描述类的域、方法、构造器。这三个类都有一个叫做getName的方法，用来返回项目的名称。</p><p>Field类有一个getType方法，用来返回描述域所属类型的Class对象。Method类有一个可以报告报告参数类型返回类型的方法，Constructor类有一个报告参数类型的方法。这三个类有一个getModifiers的方法，它返回一个整形数值，用不同的位开关描述public和static这样的修饰符使用状况。</p><p>利用java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整数数值，例如可以用isPublic、isPrivate、isFinal判断方法或构造器是否是public、private或final，还可以使用Modifier.toString方法将修饰符打印出来。</p><p>Class类中的getFields、getMethods、getConstructors方法返回类提供的public域、方法和构造器数组，其中包括超类的共有成员。getDeclareFields、getDeclareMethods、getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有和受保护的成员，但不包括超类的成员。</p><p>下面程序示例如何打印一个类的全部信息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package reflection;import java.util.*;import java.lang.reflect.*;public class ReflectionTest &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; TODO Auto-generated method stubString name;if(args.length &gt; 0) name &#x3D; args[0];else&#123;Scanner in &#x3D; new Scanner(System.in);System.out.println(&quot;Enter class name (e.g. java.util.Date): &quot;);name &#x3D; in.next();&#125;try &#123;Class c1 &#x3D; Class.forName(name);Class superc1 &#x3D; c1.getSuperclass();String modifiers &#x3D; Modifier.toString(c1.getModifiers());if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);System.out.print(&quot;class &quot; + name);if (superc1 !&#x3D; null &amp;&amp; superc1 !&#x3D; Object.class) System.out.print(&quot; extends &quot; + superc1.getName());System.out.print(&quot;\n&#123;\n&quot;);printConstructors(c1);System.out.println();printMethods(c1);System.out.println();printFields(c1);System.out.println(&quot;&#125;&quot;);&#125;catch (ClassNotFoundException e) &#123;e.printStackTrace();&#125;System.exit(0);&#125;public static void printConstructors(Class c1)&#123;Constructor[] constructors &#x3D; c1.getDeclaredConstructors();for (Constructor c : constructors)&#123;String name &#x3D; c.getName();System.out.print(&quot;  &quot;);String modifiers &#x3D; Modifier.toString(c.getModifiers());if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);System.out.print(name + &quot;(&quot;);Class[] paramTypes &#x3D; c.getParameterTypes();for(int j &#x3D; 0; j &lt; paramTypes.length; j++) &#123;if (j &gt; 0) System.out.print(&quot;, &quot;);System.out.print(paramTypes[j].getName());&#125;System.out.println(&quot;);&quot;);&#125;&#125;public static void printMethods(Class c1)&#123;Method[] methods &#x3D; c1.getDeclaredMethods();for (Method m : methods)&#123;Class retType &#x3D; m.getReturnType();String name &#x3D; m.getName();System.out.print(&quot;  &quot;);String modifiers &#x3D; Modifier.toString(m.getModifiers());if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;);Class[] paramTypes &#x3D; m.getParameterTypes();for (int j &#x3D; 0; j &lt; paramTypes.length; j++)&#123;if (j &gt; 0) System.out.print(&quot;, &quot;);System.out.print(paramTypes[j].getName());&#125;System.out.println(&quot;);&quot;);&#125;&#125;public static void printFields(Class c1)&#123;Field[] fields &#x3D; c1.getDeclaredFields();for(Field f:fields)&#123;Class type &#x3D; f.getType();String name &#x3D; f.getName();System.out.print(&quot;  &quot;);String modifiers &#x3D; Modifier.toString(f.getModifiers());if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);System.out.println(type.getName() + &quot; &quot; + name + &quot;;&quot;);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">APIjava.lang.ClassField[] getFields()Field[] getDeclaredFields()getFields方法返回一个包含Field对象的数组，这些对象记录了这个类或其超类的公有域。getDeclaredFields方法也将返回包含Field对象的数组，这些对象记录了这个类的全部域。Method[] getMethods()Method[] getDeclaredMethods()返回包含Method对象的数组：getMethods将返回所有的公有方法，包含从超类继承的共有方法；getDeclaredMethods返回这个类或接口的全部方法，但不包括由超类继承的方法。Constructor[] getConstructors()Constructor[] getDeclaredConstructors()返回包含Constructor对象的数组，其中包含了Class对象所描述的类的所有共有构造器(getConstructors)或所有构造器(getDeclaredConstructors);java.lang.reflect.Field&#x2F;Method&#x2F;ConstructorClass getDeclaringClass()返回一个用于描述类中定义的构造器、方法或域的Class对象。Class[] getExceptionTypes()(在Constructor和Method类中)返回一个用于描述方法抛出的异常类型的Class对象数组int getModifiers()返回一个用于描述构造器、方法或域的修饰符的整形数值。使用Modifier类中的这个方法可以分析这个返回值。String getName()返回一个用于描述构造器、方法或域名的字符串Class[] getParameterTypes()(在Constructor和Method类中)返回一个用于描述参数类型的Class对象数组。Class[] getReturnType()(在Method类中)返回一个用于描述返回类型的Class对象 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-4-在运行时使用反射分析对象"><a href="#5-6-4-在运行时使用反射分析对象" class="headerlink" title="5.6.4 在运行时使用反射分析对象"></a>5.6.4 在运行时使用反射分析对象</h3><p>上一节学习了如何查看任意对象的数据域名称和类型：</p><ul><li>获得对应的Class对象</li><li>通过Class对象调用getDeclaredFields</li></ul><p>利用反射机制还可以查看在编译时还不清楚的对象域。<br>查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个对象，其值为obj域的当前值。运行示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee harry &#x3D; new Employee(&quot;Harry Hacker&quot;, 35000, 10, 1, 1989);Class c1 &#x3D; harry.getClass();Field f &#x3D; c1.getDeclaredField(&quot;name&quot;);&#x2F;&#x2F; the name field of the Employee classObject v &#x3D; f.get(harry);&#x2F;&#x2F; the value of the name field of the harry object, i.e., the String object &quot;Harry Hacker&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，name是一个私有域，get方法受到访问权限的限制，需要调用Field、Method或Constructor对象的setAccessible方法。例如：</p><p><code>f.setAccessible(true);        //now OK to call f.get(harry)</code></p><p>注：setAccessible方法是AccessibleObject类中的一个方法，它是Field、Method、Constructor<br>类的公共超类。</p><p>get方法还存在一个问题：name域是一个String，因此将它作为Object返回没有什么问题，但是对于salary域，它属于double类型，double类型不是对象，反射机制将会自动把这个域值打包到相应的对象包装器中，这里将打包成Double。</p><p><code>f.set(obj, value)</code>可以将obj对象的f域设置成新值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">APIjava.lang.reflect.AccessibleObjectvoid setAccessible(boolean flag)boolean isAccessible()static void setAccessible(AccessibleObject[] array, boolean flag)java.lang.ClassField getField(String name)Field[] getField()Field getDeclaredField(String name)Field[] getDeclaredFields()java.lang.reflect.FieldObject get(Object obj)void set(Object obj, Object newValue)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-5-使用反射编写泛型数组代码"><a href="#5-6-5-使用反射编写泛型数组代码" class="headerlink" title="5.6.5 使用反射编写泛型数组代码"></a>5.6.5 使用反射编写泛型数组代码</h3><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static Object goodCopyOf(Object a, int newLength)&#123;Class c1 &#x3D; a.getClass();if (!c1.isArray()) return null;Class componentType &#x3D; c1.getComponentType();int length &#x3D; Array.getLength(a);Object newArray &#x3D; Array.newInstance(componentType, newLength);System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));return newArray;&#125;int[] a &#x3D; &#123;1, 2, 3, 4, 5&#125;;a &#x3D; (int[]) goodCopyOf(a, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-6-调用任意方法"><a href="#5-6-6-调用任意方法" class="headerlink" title="5.6.6 调用任意方法"></a>5.6.6 调用任意方法</h3><p>反射机制允许你调用任意方法</p><p>与Field类的get方法查看对象域的过程类似，Method类中有一个invoke方法，它允许调用包装在当前Method对象中的方法。</p><p><code>Object invoke(Object obj, Object...args)</code></p><p>第一个参数是隐式参数，其余的对象提供了显示参数。对于静态方法，第一个参数可以忽略。<br>例如，假设用m1代表Employee类的getName方法，下面这条语句演示了如何调用这个方法：</p><p><code>String n = (String) m1.invoke(harry);</code></p><p>可以由Class类中的getMethod方法得到一个Method对象，它与getField方法类似，但是可能存在同名的方法，因此，还必须提供想要的方法夫人参数类型。</p><p><code>Method getMethod(String name, Class... parameterTypes)</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Method m1 &#x3D; Employee.class.getMethod(&quot;getName&quot;);Method m2 &#x3D; Employee.class.getMethod(&quot;raiseSalary&quot;, double.class);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使得代码的执行速度更快，更易于维护。</p><h2 id="5-7-继承的设计技巧"><a href="#5-7-继承的设计技巧" class="headerlink" title="5.7 继承的设计技巧"></a>5.7 继承的设计技巧</h2><p>设计继承关系的建议：</p><ul><li>将公共操作和域放在超类</li><li>不要使用受保护的域</li><li>使用继承实现”is-a”关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>在覆盖方法时，不要改变预期的行为</li><li>使用多态，而非类型信息</li><li>不要过多地使用反射</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java异常学习</title>
      <link href="2020/121616109.html"/>
      <url>2020/121616109.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java异常学习"><a href="#Java异常学习" class="headerlink" title="Java异常学习"></a>Java异常学习</h1><h2 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    Scanner in &#x3D; new Scanner(System.in);    int[] a &#x3D; new int[10];  &#x2F;&#x2F;创建长度为10的一维数组    int idx;    idx &#x3D; in.nextInt();     &#x2F;&#x2F;由用户输入数组索引    try&#123;        a[idx] &#x3D; 10;        System.out.println(&quot;hello&quot;);    &#125;    catch (ArrayIndexOutOfBoundsException e) &#123;        System.out.println(&quot;caught&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码捕获ArrayIndexOutOfBoundsException异常，当用户输入idx值超过数组最大索引时，触发异常捕获，print(“hello”)部分将不会执行，输出”caught”。</p><h2 id="1-2基本代码格式"><a href="#1-2基本代码格式" class="headerlink" title="1.2基本代码格式"></a>1.2基本代码格式</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    &quot;代码块&quot;&#125;catch (exception1 e)&#123;    &quot;处理exception1异常的代码&quot;&#125;catch (exception2 e)&#123;    &quot;处理exception2异常的代码&quot;&#125;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-异常捕捉机制"><a href="#1-3-异常捕捉机制" class="headerlink" title="1.3 异常捕捉机制"></a>1.3 异常捕捉机制</h2><p><img src="/images/Exception.PNG" alt="异常捕获机制" title="Exception"></p><h2 id="1-4-捕获异常后如何处理"><a href="#1-4-捕获异常后如何处理" class="headerlink" title="1.4 捕获异常后如何处理"></a>1.4 捕获异常后如何处理</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">catch (exception e)&#123;    System.println(e.getMessage());    System.println(e);    e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体如何处理取决于业务逻辑需要<br>如果不需要在当前层面处理异常，则可以再次抛出，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">catch (exception e)&#123;    &quot;该层处理逻辑&quot;    throw e;    &#x2F;&#x2F;再次抛出异常，由下一层处理&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-示例"><a href="#1-5-示例" class="headerlink" title="1.5 示例"></a>1.5 示例</h2><p>读文件的步骤：</p><ol><li>打开文件</li><li>判断文件大小</li><li>分配内存</li><li>把文件内容读入内存</li><li>关闭文件<br>每一步依赖上一步的正常工作。<pre class="line-numbers language-java" data-language="java"><code class="language-java">try&#123;    open the file;    determine its size;    allocate that much memory;    read the file into memory;    close the file;&#125;catch(fileOpenFailed)&#123;    doSomething;&#125;catch(sizeDeterminationFailed)&#123;    doSomething;&#125;catch(memoryAllocationFailed)&#123;    doSomething;&#125;catch(readFailed)&#123;    doSomething;&#125;catch(fileCloseFailed)&#123;    doSomething;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>异常机制分开了业务逻辑和错误处理代码。</li></ol><h3 id="1-6-异常的抛出"><a href="#1-6-异常的抛出" class="headerlink" title="1.6 异常的抛出"></a>1.6 异常的抛出</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class OpenException extends Throwable&#123;  &#x2F;&#x2F;能抛出异常的类继承了Throwable类&#125;&#x2F;&#x2F;Exception类继承了Throwable类，自定义类也可以继承自Exception类。public static void readFile() throws OpenException&#123; &#x2F;&#x2F;如果函数可能抛出异常，则要添加throws    if(open() &#x3D;&#x3D; -1)&#123;               &#x2F;&#x2F;而对于想ArrayIndexOutOfBoundsException这样的异常是不用声明的        throw new OpenException();    &#125;&#125;public static void main(String[] args)&#123;    try&#123;        readFile();    &#125; catch(OpenException e)&#123;        ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-7-catch是怎么匹配异常的"><a href="#1-7-catch是怎么匹配异常的" class="headerlink" title="1.7 catch是怎么匹配异常的"></a>1.7 catch是怎么匹配异常的</h3><p>is-A的关系<br>抛出子类的异常能被捕获父类异常的catch捕捉到<br>因此<code>catch(Exception e)</code>可以捕捉任何异常</p><h3 id="1-8-异常遇到继承"><a href="#1-8-异常遇到继承" class="headerlink" title="1.8 异常遇到继承"></a>1.8 异常遇到继承</h3><ul><li><p>子类中成员函数不能抛出与父类同名的成员函数更多的异常，因为存在用一个父类类型管理子类对象的情况</p></li><li><p>子类的构造函数应包含父类构造函数抛出的异常，应为生成子类对象时会调用父类的构造函数。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础语法</title>
      <link href="2020/121516108.html"/>
      <url>2020/121516108.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法教程"><a href="#Markdown语法教程" class="headerlink" title="Markdown语法教程"></a>Markdown语法教程</h1><h2 id="1-Markdown标题语法"><a href="#1-Markdown标题语法" class="headerlink" title="1.Markdown标题语法"></a>1.Markdown标题语法</h2><p>在单词或短语前添加#号，#的数量代表了标题的级别</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># here's is a heading</span></code></pre><h1 id="here’s-is-a-heading"><a href="#here’s-is-a-heading" class="headerlink" title="here’s is a heading"></a>here’s is a heading</h1><h2 id="2-Markdown段落语法"><a href="#2-Markdown段落语法" class="headerlink" title="2.Markdown段落语法"></a>2.Markdown段落语法</h2><p>使用空白行将一行或多行文本进行分隔  </p><pre class=" language-bash"><code class="language-bash">I really like using  Markdown.I think I'll use it to   <span class="token function">format</span> all of my  documents from now on.</code></pre><p>I really like using<br>Markdown.</p><p>I think I’ll use it to<br>format all of my<br>documents from now on.</p><h2 id="3-Markdown换行语法"><a href="#3-Markdown换行语法" class="headerlink" title="3.Markdown换行语法"></a>3.Markdown换行语法</h2><p>在一行的末尾添加两个或多个空格，然后按回车键，即可创建一个换行。<br><code>This is the first line.\s\s   And this is the second   line.\s\s</code></p><p>This is the first line.<br>And this is the second<br>line.  </p><h2 id="4-Markdown强调语法"><a href="#4-Markdown强调语法" class="headerlink" title="4.Markdown强调语法"></a>4.Markdown强调语法</h2><h3 id="粗体（bold）"><a href="#粗体（bold）" class="headerlink" title="粗体（bold）"></a>粗体（bold）</h3><p>要加粗文本，在单词或短语的前后各添加两个星号。  </p><pre class=" language-bash"><code class="language-bash">Love**is**bold</code></pre><p>Love<strong>is</strong>bold</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>在单词或短语前后添加一个星号或下划线  </p><pre class=" language-bash"><code class="language-bash">Italicized text is the *cat<span class="token string">'s meow*.  Italicized text is the _cat'</span>s meow_.  A*cat*meow</code></pre><p>Italicized text is the <em>cat’s meow</em>.<br>Italicized text is the <em>cat’s meow</em>.<br>A<em>cat</em>meow  </p><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><p>要同时用粗体和斜体突出显示文本，在单词或短语的前后各添加三个星号或下划线。  </p><pre class=" language-bash"><code class="language-bash">This text is ***really important***.  This text is ___really important___.  This text is __*really important*__.  This text is **_really important_**.</code></pre><p>This text is <strong><em>really important</em></strong>.<br>This text is <strong><em>really important</em></strong>.<br>This text is <strong><em>really important</em></strong>.<br>This text is <strong><em>really important</em></strong>.  </p><h2 id="5-Markdown引用语法"><a href="#5-Markdown引用语法" class="headerlink" title="5.Markdown引用语法"></a>5.Markdown引用语法</h2><p>要创建块引用，在段落前添加一个&gt;符号</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> Dorothy followed her through many of the beautiful rooms <span class="token keyword">in</span> her castle.</code></pre><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><p>多个段落的块引用，为段落之间的空白行添加一个&gt;符号。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span>Dorothy followed her through many of the beautiful rooms <span class="token keyword">in</span> her castle.<span class="token operator">></span><span class="token operator">></span>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</code></pre><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><p>嵌套块引用，在要嵌套的段落前添加一个&gt;&gt;符号。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span>Dorothy followed her through many of the beautiful rooms <span class="token keyword">in</span> her castle.<span class="token operator">></span><span class="token operator">>></span>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</code></pre><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<br>带有其他元素的块引用块引用可以包含其他Markdown格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p></blockquote></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> <span class="token comment" spellcheck="true">#### The quarterly results look great!</span><span class="token operator">></span><span class="token operator">></span> - Revenue was off the chart.<span class="token operator">></span> - profits were higher than ever.<span class="token operator">></span><span class="token operator">></span>  *Everything* is going according to **plan**.</code></pre><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h2 id="6-Markdown列表语法"><a href="#6-Markdown列表语法" class="headerlink" title="6.Markdown列表语法"></a>6.Markdown列表语法</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字1起始。<br>示例1</p><pre class=" language-bash"><code class="language-bash">1. first item2. Second item</code></pre><ol><li>first item</li><li>Second item</li></ol><p>示例2  </p><pre class=" language-bash"><code class="language-bash">1. First item2. Second item</code></pre><ol><li>First item</li><li>Second item</li></ol><p>示例3</p><pre class=" language-bash"><code class="language-bash">1. First item2. Second item</code></pre><ol><li>First item</li><li>Second item</li></ol><p>示例4</p><pre class=" language-bash"><code class="language-bash">1. First item2. Second item3. Third item    1. Indented item    2. Indented item4. Fourth item</code></pre><ol><li>First item</li><li>Second item</li><li>Third item<ol><li>Indented item</li><li>Indented item</li></ol></li><li>Fourth item</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号（-）、星号（*）或加号（+）。缩进一个或多个列表项可创建嵌套列表。<br>示例1</p><pre class=" language-bash"><code class="language-bash"> - First item - Second item - Third item - Fourth item</code></pre><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul><p>示例2</p><pre class=" language-bash"><code class="language-bash">* First item* Second item* Third item* Fourth item</code></pre><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul><p>示例3</p><pre class=" language-bash"><code class="language-bash">+ First item+ Second item+ Third item+ Fourth item</code></pre><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul><p>示例4</p><pre class=" language-bash"><code class="language-bash">- First item- Second item- Third item - Indented item - Indented item- Fourth item</code></pre><ul><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ul><h3 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a>在列表中嵌套其他元素</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。</p><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><pre class=" language-bash"><code class="language-bash">* This is the first list item.* Here<span class="token string">'s the second list item.    I need to add another paragraph below the second list item.* And here'</span>s the third list item.</code></pre><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>  I need to add another paragraph below the   second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><pre class=" language-bash"><code class="language-bash">* This is the first list item.* Here<span class="token string">'s the second list item.    > A blockquote would look great below the second list item.* And here'</span>s the third list item.</code></pre><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here’s the third list item.</p></li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</p><pre class=" language-bash"><code class="language-bash">1.  Open the file.2.  Find the following code block on line 21:    ``<span class="token variable"><span class="token variable">`</span><span class="token function">bash</span>        <span class="token operator">&lt;</span>html<span class="token operator">></span>            <span class="token operator">&lt;</span>head<span class="token operator">></span>            <span class="token operator">&lt;</span>title<span class="token operator">></span>Test<span class="token operator">&lt;</span>/title<span class="token operator">></span>            <span class="token operator">&lt;</span>/head<span class="token operator">></span>    <span class="token variable">`</span></span>``3.  Update the title to match the name of your website.</code></pre><ol><li><p> Open the file.</p></li><li><p>Find the following code block on line 21:</p><pre><code> &lt;html&gt;   &lt;head&gt;     &lt;title&gt;Test&lt;/title&gt;   &lt;/head&gt;</code></pre></li><li><p> Update the title to match the name of your website.</p></li></ol><h2 id="7-Markdown代码语法"><a href="#7-Markdown代码语法" class="headerlink" title="7.Markdown代码语法"></a>7.Markdown代码语法</h2><p>要将单词或短语表示为代码，请将其包裹在反引号中。  </p><pre class=" language-bash"><code class="language-bash">At the <span class="token function">command</span> prompt,<span class="token function">type</span> <span class="token variable"><span class="token variable">`</span><span class="token function">nano</span><span class="token variable">`</span></span></code></pre><p>At the command prompt,<br>type <code>nano</code></p><h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号中。  </p><pre class=" language-bash"><code class="language-bash">`<span class="token variable"><span class="token variable">`</span>Use <span class="token variable">`</span></span>code<span class="token variable"><span class="token variable">`</span> <span class="token keyword">in</span>  your  Markdown file.<span class="token variable">`</span></span>`</code></pre><p><code>Use `code` in  your   Markdown file.</code></p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p><pre class=" language-bash"><code class="language-bash">    <span class="token operator">&lt;</span>html<span class="token operator">></span>     <span class="token operator">&lt;</span>head<span class="token operator">></span>     <span class="token operator">&lt;</span>/head<span class="token operator">></span>    <span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>  如下：</p><pre class=" language-bash"><code class="language-bash">    <span class="token operator">&lt;</span>html<span class="token operator">></span>     <span class="token operator">&lt;</span>head<span class="token operator">></span>     <span class="token operator">&lt;</span>/head<span class="token operator">></span>    <span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><h2 id="8-Markdown分隔线语法"><a href="#8-Markdown分隔线语法" class="headerlink" title="8.Markdown分隔线语法"></a>8.Markdown分隔线语法</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号（***）、破折号（—）或下划线（___）,并且不能包含其他内容。</p><pre class=" language-bash"><code class="language-bash">Try to put a blank line before<span class="token punctuation">..</span>.***<span class="token punctuation">..</span>.and after a horizontal rule.</code></pre><p>Try to put a blank line before…</p><hr><p>…and after a horizontal rule.</p><h2 id="9-Markdown链接语法"><a href="#9-Markdown链接语法" class="headerlink" title="9.Markdown链接语法"></a>9.Markdown链接语法</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<br>超链接Markdown语法代码：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>超链接显示名<span class="token punctuation">]</span><span class="token punctuation">(</span>超链接地址 “超链接title”<span class="token punctuation">)</span>这是一个链接<span class="token punctuation">[</span>Markdown语法<span class="token punctuation">]</span><span class="token punctuation">(</span>https://markdown.com.cn<span class="token punctuation">)</span>。</code></pre><p>这是一个链接<a href="https://markdown.com.cn/">Markdown语法</a>。</p><h3 id="给链接增加Title"><a href="#给链接增加Title" class="headerlink" title="给链接增加Title"></a>给链接增加Title</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。</p><pre class=" language-bash"><code class="language-bash">这是一个链接 <span class="token punctuation">[</span>Markdown语法<span class="token punctuation">]</span><span class="token punctuation">(</span>https://markdown.com.cn <span class="token string">"最好的markdown教程"</span><span class="token punctuation">)</span>。</code></pre><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><h3 id="网址和Email地址"><a href="#网址和Email地址" class="headerlink" title="网址和Email地址"></a>网址和Email地址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>https://markdown.com.cn<span class="token operator">></span><span class="token operator">&lt;</span>fake@example.com<span class="token operator">></span></code></pre><p><a href="https://markdown.com.cn/">https://markdown.com.cn</a><br><a href="mailto:&#x66;&#x61;&#107;&#101;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#109;">&#x66;&#x61;&#107;&#101;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#109;</a></p><h3 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h3><p>强调链接，在链接语法前后增加星号。要将链接表示为代码，请在方括号中添加反引号。</p><pre class=" language-bash"><code class="language-bash">I love supporting the **<span class="token punctuation">[</span>EFF<span class="token punctuation">]</span><span class="token punctuation">(</span>https://eff.org<span class="token punctuation">)</span>**.This is the *<span class="token punctuation">[</span>Markdown Guide<span class="token punctuation">]</span><span class="token punctuation">(</span>https://www.markdownguide.org<span class="token punctuation">)</span>*.See the section on <span class="token punctuation">[</span><span class="token variable"><span class="token variable">`</span>code<span class="token variable">`</span></span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">#code).</span></code></pre><p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em>.<br>See the section on <a href="#code"><code>code</code></a>.</p><h3 id="引用类型链接"><a href="#引用类型链接" class="headerlink" title="引用类型链接"></a>引用类型链接</h3><p>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。</p><h4 id="链接的第一部分格式"><a href="#链接的第一部分格式" class="headerlink" title="链接的第一部分格式"></a>链接的第一部分格式</h4><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母、数字、空格或标点符号。</p><p>以下示例格式对于链接的第一部分效果相同：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>hobbit-hole<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">[</span>hobbit-hole<span class="token punctuation">]</span> <span class="token punctuation">[</span>1<span class="token punctuation">]</span></code></pre><p>链接的第二部分格式<br>引用类型链接的第二部分使用以下属性设置格式：<br>1.放在括号中的标签，其后紧跟一个冒号和至少一个空格(例如<code>[label]:</code>)。<br>2.链接的URL，可以选择将其括在尖括号中。<br>3.链接的可选标题，可以将其括在双引号中，单引号或括号中。</p><p>以下示例格式对于链接的第二部分效果相同：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>1<span class="token punctuation">]</span>: https://en.wikipedia.org/wiki/Hobbit<span class="token comment" spellcheck="true">#Lifestyle</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>: https://en.wikipedia.org/wiki/Hobbit<span class="token comment" spellcheck="true">#Lifestyle "Hobbit lifestyles"</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>: https://en.wikipedia.org/wiki/Hobbit<span class="token comment" spellcheck="true">#Lifestyle 'Hobbit lifestyles'</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>: https://en.wikipedia.org/wiki/Hobbit<span class="token comment" spellcheck="true">#Lifestyle (Hobbit lifestyles)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>: <span class="token operator">&lt;</span>https://en.wikipedia.org/wiki/Hobbit<span class="token comment" spellcheck="true">#Lifestyle> "Hobbit lifestyles"</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>: <span class="token operator">&lt;</span>https://en.wikipedia.org/wiki/Hobbit<span class="token comment" spellcheck="true">#Lifestyle> 'Hobbit lifestyles'</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>: <span class="token operator">&lt;</span>https://en.wikipedia.org/wiki/Hobbit<span class="token comment" spellcheck="true">#Lifestyle> (Hobbit lifestyles)</span></code></pre><p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾(例如尾注或脚注)。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>hobbit-hole<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>: <span class="token operator">&lt;</span>https://en.wikipedia.org/wiki/Hobbit<span class="token comment" spellcheck="true">#Lifestyle> (Hobbit lifestyles)</span></code></pre><p><a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle" title="Hobbit lifestyles">hobbit-hole</a></p><h2 id="10-Markdown图片语法"><a href="#10-Markdown图片语法" class="headerlink" title="10.Markdown图片语法"></a>10.Markdown图片语法</h2><p>要添加图像，请使用感叹号(<code>!</code>)，然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：<code>![图片alt](图片链接&quot;图片title&quot;)</code>。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">!</span><span class="token punctuation">[</span>这是蒲公英图片<span class="token punctuation">]</span><span class="token punctuation">(</span>/images/flower.jpg <span class="token string">"Magic Gardens"</span><span class="token punctuation">)</span></code></pre><p><img src="/images/flower.jpg" alt="这是蒲公英图片" title="Magic Gardens"></p><p>给图片增加链接，请将图像的Markdown括在方括号中，然后将链接添加在圆括号中。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token operator">!</span><span class="token punctuation">[</span>宠物猫<span class="token punctuation">]</span><span class="token punctuation">(</span>/images/cat.jpg <span class="token string">"Shiprock"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https://markdown.com.cn<span class="token punctuation">)</span></code></pre><p><a href="https://markdown.com.cn/"><img src="/images/cat.jpg" alt="宠物猫" title="Shiprock"></a></p><h2 id="11-Markdown转义字符语法"><a href="#11-Markdown转义字符语法" class="headerlink" title="11.Markdown转义字符语法"></a>11.Markdown转义字符语法</h2><p>要显示原本用于格式化Markdown文档的字符，请在字符前面添加反斜杠字符。</p><pre class=" language-bash"><code class="language-bash">\* Without the backslash, this would be a bullet <span class="token keyword">in</span> an unordered list.</code></pre><p>* Without the backslash, this would be a bullet in an unordered list.</p><h3 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p><table><thead><tr><th align="center">Character</th><th align="left">Name</th></tr></thead><tbody><tr><td align="center">\</td><td align="left">backslash</td></tr><tr><td align="center">`</td><td align="left">backtick</td></tr><tr><td align="center">*</td><td align="left">asterisk</td></tr><tr><td align="center">_</td><td align="left">underscore</td></tr><tr><td align="center">{}</td><td align="left">curly braces</td></tr><tr><td align="center">[]</td><td align="left">brackets</td></tr><tr><td align="center">()</td><td align="left">parentheses</td></tr><tr><td align="center">#</td><td align="left">pound sign</td></tr><tr><td align="center">+</td><td align="left">plus sign</td></tr><tr><td align="center">-</td><td align="left">minus sign (hyphen)</td></tr><tr><td align="center">.</td><td align="left">dot</td></tr><tr><td align="center">!</td><td align="left">exclamation mark</td></tr><tr><td align="center">|</td><td align="left">pipe</td></tr></tbody></table><h2 id="12-Markdown内嵌HTML标签"><a href="#12-Markdown内嵌HTML标签" class="headerlink" title="12.Markdown内嵌HTML标签"></a>12.Markdown内嵌HTML标签</h2><p>对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可。</p><h3 id="行级内联标签"><a href="#行级内联标签" class="headerlink" title="行级内联标签"></a>行级内联标签</h3><p>HTML的行级内联标签如<code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code>不受限制，可以在Markdown的段落、列表或是标题里任意使用。按照个人习惯，甚至可以不用Markdown格式，而采用HTML标签来格式化。例如：如果比较喜欢HTML的<code>&lt;a&gt;</code>或<code>&lt;img&gt;</code>标签，可以直接使用这些标签，而不用Markdown提供的链接或是图片语法。当需要更改元素的属性时，使用HTML标签更方便些。</p><p>HTML行级内联标签和区块标签不同，在内联标签的范围内，Markdown的语法是可以解析的。</p><pre class=" language-bash"><code class="language-bash">This **word** is bold. This <span class="token operator">&lt;</span>em<span class="token operator">></span>word<span class="token operator">&lt;</span>/em<span class="token operator">></span> is italic.</code></pre><p>This <strong>word</strong> is bold. This <em>word</em> is italic.</p><h3 id="区块标签"><a href="#区块标签" class="headerlink" title="区块标签"></a>区块标签</h3><p>区块元素——比如<code>&lt;div&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code>等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用tab或是空白来缩进。<br>Markdown会自动识别这区块元素，避免在区块标签前后加上没有必要的<code>&lt;p&gt;</code>标签。</p><p>例如，在Markdown文件里加上一段HTML表格：</p><pre class=" language-bash"><code class="language-bash">This is a regular paragraph.<span class="token operator">&lt;</span>table<span class="token operator">></span>    <span class="token operator">&lt;</span>tr<span class="token operator">></span>        <span class="token operator">&lt;</span>td<span class="token operator">></span>Foo<span class="token operator">&lt;</span>/td<span class="token operator">></span>    <span class="token operator">&lt;</span>/tr<span class="token operator">></span><span class="token operator">&lt;</span>/table<span class="token operator">></span>This is another regular paragraph.</code></pre><p>This is a regular paragraph.</p><table>    <tr>        <td>Foo</td>    </tr></table><p>This is another regular paragraph.</p><p>请注意，Markdown语法在HTML区块标签中将不会被进行处理。例如，你无法在HTML区块内使用Markdown形式的<em>强调</em>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/121216107.html"/>
      <url>2020/121216107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
