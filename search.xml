<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JSP</title>
      <link href="2021/071816117.html"/>
      <url>2021/071816117.html</url>
      
        <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>jsp即java server page，是一种在服务器端用java语言编写的动态页面的技术，其本质就是servlet，在第一次请求时，会将jsp编译成一个servlet类。</p><p>由于jsp现在使用已经很少，本文简单介绍EL表达式和JSTL。</p><h2 id="EL表达式的使用"><a href="#EL表达式的使用" class="headerlink" title="EL表达式的使用"></a>EL表达式的使用</h2><h3 id="EL表达式的语法"><a href="#EL表达式的语法" class="headerlink" title="EL表达式的语法"></a>EL表达式的语法</h3><p>EL表达式让Jsp的代码更加简化，语法结构为：</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">$&#123;expression&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>EL表达式操作的一般是域对象的数据，在Jsp中域对象如：pageContext  request session application；分别表示本页面、一次请求、一次会话、整个应用程序。需要从某个特定的域对象中查找数据时可以使用四个域对象对应的空间对象，分别是：pageScope，requestScope，sessionScope，applicationScope。EL表达式查找方式为从小到大，找到即可，没有返回空字符串。</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">request.setAttribute(&quot;name&quot;, &quot;admin&quot;);$&#123;name&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="EL表达式的使用-1"><a href="#EL表达式的使用-1" class="headerlink" title="EL表达式的使用"></a>EL表达式的使用</h3><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">pageContext.setAttribute(&quot;name&quot;, &quot;admin0&quot;);request.setAttribute(&quot;name&quot;, &quot;admin1&quot;);$&#123;name&#125; &#x2F;&#x2F;admin0$&#123;requestScope.name&#125;  &#x2F;&#x2F;admin1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><p>用于判断变量是否为空</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">$&#123;empty name&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h3><p>JSTL的全称为Java Server Pages Standard Tag Libary，即JSP标准标签库。</p><p>核心标签库可参考：<a href="http://java.sun.com/jsp/jstl/core">核心标签库</a></p><p>格式化标签库：<a href="http://java.sun.com/jsp/jstl/fmt">格式化标签库</a></p><h4 id="标签的使用"><a href="#标签的使用" class="headerlink" title="标签的使用"></a>标签的使用</h4><p>为了在JSP页面使用JSTL类库，必须以下列格式使用taglib指令：</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@taglib uri&#x3D;&quot;&quot; prefix&#x3D;&quot;&quot; %&gt;&lt;%@taglib uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; prefix&#x3D;&quot;c&quot; %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同时需要导入相应的jar包jstl.jar和standard.jar，通常放在WEB-INF/lib文件夹下，在IDEA中添加依赖。</p><h4 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h4><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">- if标签  &lt;c:if test&#x3D;&quot;判断条件&quot;&gt;    &#x2F;&#x2F;满足条件时执行的代码  &lt;&#x2F;c:if&gt;&lt;%    request.setAttribute(&quot;score&quot;, 60);%&gt;&lt;c:if test&#x3D;&quot;$&#123;score &lt; 60&#125;&quot;&gt;    &lt;h2&gt;不及格&lt;&#x2F;h2&gt;&lt;&#x2F;c:if&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>forEach标签</li></ul><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;c:forEach begin&#x3D;&quot;开始&quot; end&#x3D;&quot;结束数&quot; step&#x3D;&quot;间隔&quot; var&#x3D;&quot;限域变量名&quot;&gt;    &#x2F;&#x2F;循环体内容&lt;&#x2F;c:forEach&gt;&lt;c:forEach items&#x3D;&quot;要遍历的集合&quot; var&#x3D;&quot;限域变量名&quot;&gt;    &#x2F;&#x2F;执行的操作&lt;&#x2F;c:forEach&gt;&lt;c:forEach begin&#x3D;&quot;0&quot; end&#x3D;&quot;&quot; step&#x3D;&quot;1&quot; var&#x3D;&quot;i&quot;&gt;    $&#123;i&#125;&lt;&#x2F;c:forEach&gt;&lt;c:forEach items&#x3D;&quot;$&#123;mylist&#125;&quot; var&#x3D;&quot;item&quot;&gt;    $&#123;item&#125;&lt;&#x2F;c:forEach&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="过滤器和监听器"><a href="#过滤器和监听器" class="headerlink" title="过滤器和监听器"></a>过滤器和监听器</h2><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Filter即为过滤器，用于在Servlet之外对Request和Response进行修改，使用Filter的过程为：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理，在一个web应用中可以编写多个Filter，这些Filter组合起来称为一个Filter链。</p><h4 id="过滤器实现"><a href="#过滤器实现" class="headerlink" title="过滤器实现"></a>过滤器实现</h4><ul><li>创建java类并实现Filter接口</li><li>实现doFilter方法，对请求和响应进行相应处理</li><li>设置需要被过滤的资源@WebFilter(“/…”)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.example.demo;import javax.servlet.*;import java.io.IOException;&#x2F;** 过滤器的实现*   1.创建普通java类*   2.实现Filter接口*   3.实现方法*   4.设置需要被过滤的资源*       @WebFilter(&quot;&#x2F;拦截的资源路径&quot;)**&#x2F;@WebFilter(&quot;&#x2F;Servlet01&quot;)public class Filter01 implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        Filter.super.init(filterConfig);    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        &#x2F;&#x2F;请求预处理        System.out.println(&quot;doFilter 请求处理...&quot;);        &#x2F;&#x2F;放行资源        filterChain.doFilter(servletRequest, servletResponse);        &#x2F;&#x2F;响应后处理        System.out.println(&quot;doFilter01 处理响应...&quot;);    &#125;    @Override    public void destroy() &#123;        Filter.super.destroy();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过滤器作用"><a href="#过滤器作用" class="headerlink" title="过滤器作用"></a>过滤器作用</h4><p>如处理请求乱码，用户非法访问拦截等</p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>web监听器是Servlet中一种特殊的类，能帮助开发者监听web中的特定事件，比如ServletContext，HttpSession，ServletRequest的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。如可以用来统计在线人数等。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>监听器有三类8种：</p><ul><li>监听生命周期<ul><li>ServletRequestListener</li><li>HttpSessionListener</li><li>ServletContextListener</li></ul></li><li>监听值的变化<ul><li>ServletRequestAttributeListener</li><li>HttpSessionAttributeListener</li><li>ServletContextAttributeListener</li></ul></li><li>针对session中的对象<ul><li>javaBean</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>实现监听的接口</li><li>在监听类中添加注解@WebListener</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.example.demo;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;&#x2F;** * 监听在线人数 *      当有用户访问，创建session对象，人数加1 *      当有用户退出，销毁session对象，人数减1 *&#x2F;@WebListenerpublic class Listener01 implements HttpSessionListener &#123;    private int onlineNum &#x3D; 0;    @Override    public void sessionCreated(HttpSessionEvent se) &#123;        onlineNum++;        &#x2F;&#x2F;数据设置到application作用域        se.getSession().getServletContext().setAttribute(&quot;onlineNum&quot;, onlineNum);    &#125;    @Override    public void sessionDestroyed(HttpSessionEvent se) &#123;        onlineNum--;        se.getSession().getServletContext().setAttribute(&quot;onlineNum&quot;, onlineNum);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="2021/071716116.html"/>
      <url>2021/071716116.html</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet是一个java类，用于处理客户端请求，并返回相应内容，Tomcat相当于管理Servlet类的容器。</p><h2 id="Servlet对象"><a href="#Servlet对象" class="headerlink" title="Servlet对象"></a>Servlet对象</h2><h3 id="创建HttpServlet类"><a href="#创建HttpServlet类" class="headerlink" title="创建HttpServlet类"></a>创建HttpServlet类</h3><p>要创建自定义的HttpServlet类，只需要继承HttpServlet，通过重写service()方法或者doGet(),doPost()等方法来实现请求的处理与响应，http请求发出后，到达服务器，服务器找到Tomcat进程，然后根据请求体的内容生成request对象，response对象，同时由请求头的URL参数找到对应的servlet类，并创建该servlet并初始化(init()方法)，将request对象及response对象作为参数传递给响应的方法（如doGet方法），Servlet类做处理后将更新response对象由tomcat返回请求的客户，因此每个servlet类应有对应的访问url，在IDEA中可通过注解来实现，例如：</p><pre class="line-numbers language-none"><code class="language-none">@WebServlet(name &#x3D; &quot;helloServlet&quot;, value &#x3D; &quot;&#x2F;hello-servlet&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在合适的时机，tomcat可以销毁servlet对象，此时会调用destory()方法。</p><h3 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h3><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>request对象有一些常用的方法，可以用来获取相应的请求信息。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>获取客户端请求的完整URL</td></tr><tr><td>getRequestURI()</td><td>获取请求行中的资源名称部分</td></tr><tr><td>getQueryString()</td><td>获取请求行中的参数部分</td></tr><tr><td>getMethod()</td><td>获取客户端请求方式</td></tr><tr><td>getProtocol</td><td>获取HTTP版本号</td></tr><tr><td>getContextPath()</td><td>获取webapp名字</td></tr><tr><td>getParameter(String name)</td><td>获取指定名称的参数</td></tr><tr><td>getParameterValues(String name)</td><td>获取指定名称参数的所有值</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">String url &#x3D; request.getRequestURL().toString();System.out.println(&quot;获取客户端请求的完整URL：&quot; + url);String queryString &#x3D; request.getQueryString();System.out.println(&quot;获取请求行中的参数部分：&quot; + queryString);String name &#x3D; request.getParameter(&quot;uname&quot;);String[] hobbies &#x3D; request.getParameterValues(&quot;hobby&quot;);&#x2F;&#x2F;乱码问题request.setCharacterEncoding(&#39;UTF-8&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>服务端的一种跳转方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">req.getRequestDispatcher(&quot;路径&quot;).forward(req, resp);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request作用域</h4><p>例如从数据库查询的数据，将数据传递给request对象，作用范围在同一次请求中有效。</p><pre class="line-numbers language-none"><code class="language-none">request.setAttribute(&quot;参数名&quot;, &quot;参数值&quot;);request.getAttribute(&quot;参数名&quot;);request.removeAttribute(&quot;参数名&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h3><p>用于服务器响应浏览器的请求的response对象。<br>响应时需要获取输出流：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getWriter():字符流getOutputStream():字节流PrintWriter writer &#x3D; response.getWriter();writer.write(&quot;hello&quot;);ServletOutputStream out &#x3D; response.getOutputStream();&#x2F;&#x2F;设置响应类型response.setHeader(&quot;content-type&quot;, &quot;text&#x2F;html&quot;);&#x2F;&#x2F;设置服务端编码response.setCharacterEncoding(&quot;UTF-8&quot;);&#x2F;&#x2F;设置客户端响应类型及编码response.setHeader(&quot;content-type&quot;, &quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向是一种跳转方式，但是是客户端的行为（请求转发是服务端行为），客户端首先发出一个请求，服务端响应请求的同时给客户端一个新的地址，客户端收到响应后，根据新地址发起第二个请求，服务器接受请求作出响应，重定向完成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">response.sendRedirect(&quot;url&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Cookie对象"><a href="#Cookie对象" class="headerlink" title="Cookie对象"></a>Cookie对象</h2><p>Cookie是浏览器提供的一种技术，将一些只需在客户端处理的数据存放在本地计算机上，操作Cookie的类为javax.servlet.http.Cookie，随着服务器端的响应发送给客户端，保存在浏览器，下次再访问服务器时把Cookie再带回服务器。</p><h3 id="Cookie的创建与发送"><a href="#Cookie的创建与发送" class="headerlink" title="Cookie的创建与发送"></a>Cookie的创建与发送</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">Cookie cookie &#x3D; new Cookie(name, value);response.addCookie(cookie);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Cookie的获取"><a href="#Cookie的获取" class="headerlink" title="Cookie的获取"></a>Cookie的获取</h3><p>获取所有的cookie后遍历，使用getName()和getValue()方法获取名字或属性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Cookie[] cookies &#x3D; request.getCookies();for (Cookie cookie : cookies)&#123;    System.out.println(cookie.getName() + &quot; &quot; + cookie.getValue());    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置Cookie的到期时间"><a href="#设置Cookie的到期时间" class="headerlink" title="设置Cookie的到期时间"></a>设置Cookie的到期时间</h3><p>通过设置Cookie对象的maxAge属性。该值默认为-1。设置为0表示删除该Cookie，正整数表示存活的秒数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Cookie cookie &#x3D; new Cookie(name, value);cookie.setmaxAge();response.addCookie(cookie);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Cookie注意点"><a href="#Cookie注意点" class="headerlink" title="Cookie注意点"></a>Cookie注意点</h3><ul><li>Cookie保存在当前浏览器中</li><li>Cookie中如果有中文，通过URLEncoder.encode()来编码，获取时通过URLDecoder.decode()来进行解码。<pre class="line-numbers language-java" data-language="java"><code class="language-java">String name &#x3D; &quot;中文&quot;；name &#x3D; URLEncoder.encode(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>服务器端发送重复的Cookie会覆盖原来的Cookie</li></ul><h3 id="Cookie的路径"><a href="#Cookie的路径" class="headerlink" title="Cookie的路径"></a>Cookie的路径</h3><p>Cookie的setPath设置cookie的路径，决定服务器是否会从浏览器中加载某些cookie</p><ul><li>当前服务器下任何项目的任意资源都可以获取Cookie对象<pre class="line-numbers language-java" data-language="java"><code class="language-java">cookie.setPath(&quot;&#x2F;&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>当前项目下的资源可获取Cookie对象（默认path）<pre class="line-numbers language-java" data-language="java"><code class="language-java">cookie.setPath(&quot;&#x2F;test&quot;);    &#x2F;&#x2F;项目名test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>指定项目下的资源可获取Cookie对象<pre class="line-numbers language-java" data-language="java"><code class="language-java">cookie.setPath(&quot;&#x2F;test01&quot;);    &#x2F;&#x2F;指定项目名test01<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>指定项目下的指定资源下可获取Cookie对象<pre class="line-numbers language-java" data-language="java"><code class="language-java">cookie.setPath(&quot;&#x2F;test&#x2F;reg&quot;);    &#x2F;&#x2F;test&#x2F;reg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="HttpSession对象"><a href="#HttpSession对象" class="headerlink" title="HttpSession对象"></a>HttpSession对象</h2><p>session属于Http协议的范畴，HttpSession对象是javax.servlet.http.HttpSession的实例。</p><p>对于服务器而言，每一个连接到它的客户端都是一个session，servlet容器使用HttpSession接口创建Http客户端和Http服务器之间的会话。会话将保留指定的时间段。</p><p>session的作用就是为了标识一次会话，或者确认一个用户，并且在一次会话期间共享数据。通过request.getSession()方法来获取当前会话的session对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建&#x2F;获取sessionHttpSession session &#x3D; request.getSession();session.getId(); &#x2F;&#x2F;会话标识符session.getCreationTime(); &#x2F;&#x2F;会话开始时间session.getLastAccessedTime(); &#x2F;&#x2F;最后一次会话时间session.isNew(); &#x2F;&#x2F;是否是新的session对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>每个会话有一个唯一的标志，即sessionId，请求到达服务器时，服务器通过客户端传来的cookie中的JSESSIONID来判断这是否是一个新的会话。</p><h3 id="session域对象"><a href="#session域对象" class="headerlink" title="session域对象"></a>session域对象</h3><p>Session表示一次会话，在一次会话中数据可以共享，session作为域对象存在。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取session对象HttpSession session &#x3D; request.getSession();&#x2F;&#x2F;设置session域对象session.setAttribute(&quot;uname&quot;, &quot;admin&quot;);&#x2F;&#x2F; 获取指定名称的session域对象session.getAttribute(&quot;uname&quot;);&#x2F;&#x2F; 移除指定名称的域对象session.removeAttribute(&quot;uname&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="session的销毁"><a href="#session的销毁" class="headerlink" title="session的销毁"></a>session的销毁</h3><h4 id="默认时间到期"><a href="#默认时间到期" class="headerlink" title="默认时间到期"></a>默认时间到期</h4><p>Tomcat中session的存活时间是30min，一旦重新操作界面，session会重新计时。可以更改session的默认存活时间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">HttpSession session &#x3D; request.getSession();session.setMaxInactiveInterval(int interval);int interval &#x3D; session.getMaxInactiveInterval();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="关闭浏览器"><a href="#关闭浏览器" class="headerlink" title="关闭浏览器"></a>关闭浏览器</h4><p>session依赖cookie，cookie默认浏览器关闭失效。</p><h4 id="关闭服务器"><a href="#关闭服务器" class="headerlink" title="关闭服务器"></a>关闭服务器</h4><p>服务器关闭session对象就销毁了</p><h4 id="手动销毁"><a href="#手动销毁" class="headerlink" title="手动销毁"></a>手动销毁</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">session.invalidate();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>文件上传涉及到前台页面和后台服务器代码的编写，前台发送文件，后台接收并保存文件，这是一个完整的文件上传。</p><h4 id="前台页面"><a href="#前台页面" class="headerlink" title="前台页面"></a>前台页面</h4><p>我们需要一个表单，表单的请求方式为POST，form表单的enctype必须为”multipart/form-data”,意思为设置表单的类型为文件上传表单。默认情况下这个表单类型是”application/x-www-form-urlencoded”，不能用于文件上传。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--     表单类型：        普通表单：enctype="application/x-www-form-urlencoded"（默认）        二进制表单：enctype="multipart/form-data"（文件上传需要设置）    提交方式：        GET请求与POST请求        文件上传需要设置为method="post"    表单元素：        文件域            &lt;input type="file"> --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test<span class="token punctuation">"</span></span><span class="token attr-name">,</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token attr-name">,</span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    姓名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token attr-name">,</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>uname<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>    文件：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token attr-name">,</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h4><p>使用注解@MultipartConfig将一个Servlet标识为支持文件上传。Servlet将multipart/form-data的POST请求封装成Part，通过Part对文件操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">request.setCharacterEncoding(&quot;UTF-8&quot;);Part part &#x3D; req.getPart(&quot;file&quot;);String uname &#x3D; request.getParameter(&quot;uname&quot;);String filename &#x3D; part.getSubmittedFileName();&#x2F;&#x2F; 设置上传文件要存放的路径(upload文件夹下)String uploadPath &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;upload&#x2F;&quot;);part.write(uploadPath + filename);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>文件下载有两种方式，一是通过超链接的本身特性来下载，二是通过代码下载。</p><h4 id="超链接下载"><a href="#超链接下载" class="headerlink" title="超链接下载"></a>超链接下载</h4><p>在html中使用&lt;a&gt;标签时，是希望进行跳转，但当超链接遇到浏览器不识别的资源时会自动下载，当浏览器能够直接显示资源时，浏览器就会默认显示出来，如txt、jpg等。我们也可以通过download属性规定浏览器进行下载。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 默认下载 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test.zip<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>超链接下载<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 指定download属性下载 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test.txt<span class="token punctuation">"</span></span> <span class="token attr-name">download</span><span class="token punctuation">></span></span>超链接下载<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h4><p>下载步骤：</p><ul><li>得到需要下载的文件名</li><li>得到下载的文件存放的路径</li><li>通过路径与文件名得到File对象</li><li>判断File对象是否存在，且是一个标准文件</li><li>设置响应类型（浏览器无法使用某种方式或激活某个程序来处理的MIME类型）</li><li>设置响应头（下载的文件名等）</li><li>得到要下载的文件输入流</li><li>得到字节输出流</li><li>循环输出</li><li>关闭流</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String fielName &#x3D; request.getParameter(&quot;fileName&quot;);String filePath &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;upload&#x2F;&quot;);File file &#x3D; new File(filePath + fileName);if (file.exists() &amp;&amp; file.isFile())&#123;    response.setContextType(&quot;application&#x2F;x-msdownload&quot;);    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename&#x3D;&quot;+fileName);    InputStream in &#x3D; new FileInputStream(file);    ServletOutputStream out &#x3D; response.getOutputStream();    int len &#x3D; 0;    byte[] bytes &#x3D; new byte[1024];    while((len &#x3D; in.read(bytes)) !&#x3D; -1)&#123;        out.write(bytes, 0, len);    &#125;    out.close();    in.close();&#125;else&#123;    response.setContentType(&quot;test&#x2F;html;charset&#x3D;UTF-8&quot;);    response.getWriter().write(&quot;&lt;h2&gt;要下载的文件不存在&lt;&#x2F;h2&gt;&quot;);    response.getWriter().close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="2021/061716115.html"/>
      <url>2021/061716115.html</url>
      
        <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>在java中，可以向其中读取一个字节序列的对象叫做输入流，可以向其中写入一个字节序列的对象称作输出流。处理字节单位的输入输出流为InputStream和OutputStream，处理字符单位的抽象类为Reader和Writer。</p><h2 id="1-输入输出流"><a href="#1-输入输出流" class="headerlink" title="1. 输入输出流"></a>1. 输入输出流</h2><h2 id="1-1-读写字节"><a href="#1-1-读写字节" class="headerlink" title="1.1 读写字节"></a>1.1 读写字节</h2><p>典型的方法如下：</p><p>abstract int read()<br>该方法读入一个字节，并返回读入的字节，遇到输入源结尾时返回-1。</p><p>abstract void write(int b)<br>该方法写出一个字节</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">API java.io.InputStreamabstract int read()int read(byte[] b)读入一个字节数组，返回实际读入的字节数，或者在碰到输入流的结尾时返回-1。最多读入b.length个字节。int read(byte[] b, int off, int len)long skip(long n)int available()返回在不阻塞的情况下可获取的字节数。void close()关闭这个输入流API java.io.OutputStreamabstract void write(int n)写出一个字节的数据void write(byte[] b)void write(byte[] b, int off, int len)void close()void flush()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java包含各种输入输出流，处理字节流使用InputStream/OutputStream及其子类，常用的如FileInputStream/FileOutputStream，BufferedInputStream/BufferedOutputStream，DataInputStream/DataOutputStream可以以二进制格式读写基本java类型。</p><p>处理字符流使用Reader\Writer及其子类，同样的有FileReader\FileWriter，BufferedReader\BufferedWriter，将字节流转为字符流的类InputStreamReader\OutPutStreamReader。</p><h3 id="1-2-流过滤器"><a href="#1-2-流过滤器" class="headerlink" title="1.2 流过滤器"></a>1.2 流过滤器</h3><p>FileInputStream\FileOutputStream提供了附着在磁盘文件上的输入流输出流，只需向其构造器提供文件名或文件的完整路劲名。例如：</p><p><code>FileInputStream fin = new FileInputStream(&quot;D:\Files\IntelliJ IDEA\test\src\\test.dat&quot;)</code></p><p>从fin对象只能读入字节或字节数组，如果我们有DataInputStream，那么就只能读入数值类型：</p><p><code>DataInputStream din = ...; double x = din.readDouble();</code></p><p>FilterInputStream\FilterOutputStream类的子类向用于处理字节的输入输出流添加额外的功能，比如想使用缓冲机制，以及用于文件的数据输入方法，就需要使用下面的构造器序列：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">DataInputStream din &#x3D; new DataInputStream(    new BufferedInputStream(        new FileInputStream(&quot;test.dat&quot;)    ));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从一个zip压缩文件中使用下面的输入流序列来读入数字</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ZipInputStream zin &#x3D; new ZipInputStream(new FileInputStream(&quot;test.zip&quot;));DataInputStream din &#x3D; new DataInputStream(zin);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将DataInputStream置于构造链的最后是因为我们需要使用DataInputStream的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">API java.io.FileInputStreamFileInputStream(String name)FileInputStream(File file)API java.io.FileOutputStreamFileOutputStream(String name)FileOutputStream(String name, boolean append)FileOutputStream(File file)FileOutputStream(File file, boolean append)API java.io.BufferedInputStreamBufferedInputStream(InputStream in)带缓冲区的输入流在从流中读入字符时，不会每次都对设备访问BufferedOutputStream(OutputStream out)API java.io.PushbackInputStreamPushbackInputStream(InputStream in)PushbackInputputStream(InputStream in, int size)void unread(int b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-文本输入与输出"><a href="#2-文本输入与输出" class="headerlink" title="2. 文本输入与输出"></a>2. 文本输入与输出</h2><p>OutputStreamWriter类将使用选定的字符编码方式，把Unicode码元的输出流转换为字节流。InputStreamReader类将包含字节的输入流转换为可以产生Unicode码元的读入器。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Reader in &#x3D; new InputStreamReader(new FileInputStream(&quot;data.txt&quot;), StandardCharsets.UTF_8);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-1-写出文本输出"><a href="#2-1-写出文本输出" class="headerlink" title="2.1 写出文本输出"></a>2.1 写出文本输出</h3><p>对于文本输出使用PrintWriter，该类拥有以文本格式打印字符串和数字的方法，同时有一个将PrintWriter链接到FileWriter的便捷方法，下面的语句：</p><p><code>PrintWriter out = new PrintWriter(&quot;test.txt&quot;, &quot;UTF-8&quot;);</code></p><p>等同于：</p><p><code>PrintWriter out = new PrintWriter(     new FileOutputStream(&quot;test.txt&quot;, &quot;UTF-8&quot;) );</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String name &#x3D; &quot;Harry Hacker &quot;;double salary &#x3D; 75000;out.print(name);out.println(salary);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将把字符”Harry Hacker 75000.0”写入到输出器out，之后字符被转换为字节并最终写入test.txt文件中。</p><h3 id="2-2-读入文本输入"><a href="#2-2-读入文本输入" class="headerlink" title="2.2 读入文本输入"></a>2.2 读入文本输入</h3><p>可以从输入流中构造Scanner对象，也可以将短小的文本文件以这种方式读入到一个字符串中：</p><p><code>String content = new String(Files.readAllBytes(path), charset)</code></p><p>如果想将文件一行一行地读入，可以调用：</p><p><code>List&lt;String&gt; lines = Files.readAllLines(path, charset);</code></p><p>如果文件太大，那么可以将行惰性处理为一个Stream<String>对象：</p><p><code>try(Stream&lt;String&gt; lines = Files.lines(path, charset))&#123;     ... &#125;</code></p><p>早期处理文本输入的唯一方式就是通过BufferedReader类，它的readLine方法会产生一行文本，在无法获得更多的输入时返回null。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">InputStream inputstream &#x3D; ...;try(BufferedReader in &#x3D; new BufferedReader(    new InputStreamReader(inputstream,                            StandardCharsets.UTF_8)))&#123;    String line;    while((line &#x3D; in.readLine()) !&#x3D; null)    &#123;        do something with line    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-以文本格式存储对象"><a href="#2-3-以文本格式存储对象" class="headerlink" title="2.3 以文本格式存储对象"></a>2.3 以文本格式存储对象</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package io;import io.Employee;import java.io.*;import java.time.LocalDate;import java.util.Scanner;public class TestFileTest &#123;    public static void main(String[] args) throws IOException &#123;        Employee[] staff &#x3D; new Employee[3];        staff[0] &#x3D; new Employee(&quot;Carl Cracker&quot;, 75000, 1987, 12, 15);        staff[1] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);        staff[2] &#x3D; new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15);        try (PrintWriter out &#x3D; new PrintWriter(&quot;employee.dat&quot;, &quot;UTF-8&quot;)) &#123;            writeData(staff, out);        &#125;        try (Scanner in &#x3D; new Scanner(new FileInputStream(&quot;employee.dat&quot;), &quot;UTF-8&quot;)) &#123;            Employee[] newStaff &#x3D; readData(in);            for (Employee e : newStaff) &#123;                System.out.println(e);            &#125;        &#125;    &#125;    private static void writeData(Employee[] employees, PrintWriter out) throws IOException    &#123;        out.println(employees.length);        for (Employee e:employees)&#123;writeEmployee(out, e);&#125;    &#125;    private static Employee[] readData(Scanner in)    &#123;        int n &#x3D; in.nextInt();        in.nextLine();        Employee[] employees &#x3D; new Employee[n];        for (int i&#x3D;0; i &lt; n; i++)&#123;            employees[i] &#x3D; readEmployee(in);        &#125;        return employees;    &#125;    public static void writeEmployee(PrintWriter out, Employee e)    &#123;        out.println(e.getName() + &quot;|&quot; + e.getSalary() + &quot;|&quot; + e.getHireDay());    &#125;    public static Employee readEmployee(Scanner in)    &#123;        String line &#x3D; in.nextLine();        String[] tokens &#x3D; line.split(&quot;\\|&quot;);        String name &#x3D; tokens[0];        double salary &#x3D; Double.parseDouble(tokens[1]);        LocalDate hireDay &#x3D; LocalDate.parse(tokens[2]);        int year &#x3D; hireDay.getYear();        int month &#x3D; hireDay.getMonthValue();        int day &#x3D; hireDay.getDayOfMonth();        return new Employee(name, salary, year, month, day);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-读写二进制数据"><a href="#3-读写二进制数据" class="headerlink" title="3. 读写二进制数据"></a>3. 读写二进制数据</h2><p>以二进制格式传递数据相比文本格式更加高效。</p><h3 id="3-1-DateInput和DataOutput接口"><a href="#3-1-DateInput和DataOutput接口" class="headerlink" title="3.1 DateInput和DataOutput接口"></a>3.1 DateInput和DataOutput接口</h3><p>DataOutput接口定义了下面用于以二进制格式写数组、字符、boolean值和字符串的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">writeCharswriteBytewriteIntwriteShortwriteLongwriteFloatwriteDoublewriteCharwriteBooleanwriteUTF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如writeInt总是将一个整数写出为4字节的二进制数量值，不管它有多少位，writeDouble总是将一个double值写出为8字节的二进制数量值。</p><p>为了读回数据，可以使用DataInput接口中的下列方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">readIntreadShortreadLongreadFloatreadDoublereadCharreadBooleanreadUTF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DataInputStream类实现了DataInput接口，为了从文件中读入二进制数据，可以将DataInputStream与某个字节源相组合，如FileInputStream：</p><p><code>DataInputStream in = new DataInputStream(new FileInputStream(&quot;employee.dat&quot;))</code></p><p>同样DataOutputStream类实现了DataOutput接口。</p><h3 id="3-2-随机访问文件"><a href="#3-2-随机访问文件" class="headerlink" title="3.2 随机访问文件"></a>3.2 随机访问文件</h3><p>RandomAccessFile类可以在文件中的任何位置查找和写入数据，磁盘文件都是随机访问的，但是与网络套接字通信的输入\输出流不是。通过字符串’r’或者’rw’指定随机访问文件的读入或同时用于读写，将已有文件作为RandomAccessFile打开时，这个文件不会被删除。</p><p>随机访问文件有一个表示下一个字节位置的文件指针，seek方法可以设置这个指针的位置，参数是一个long类型的整数，其值位于0到文件按照字节来度量的长度之间。</p><p>getFilePointer方法将返回文件指针的当前位置。</p><p>RandomAccessFile类同时实现了DataInput\DataOutput接口，可以使用前文提到的readInt\writeInt,readChar\writeChar等方法。</p><p>示例程序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package randomAccess;import io.Employee;import java.io.*;import java.time.LocalDate;public class randomAccessTest &#123;    public static void main(String[] args) throws IOException &#123;        Employee[] staff &#x3D; new Employee[3];        staff[0] &#x3D; new Employee(&quot;Carl Cracker&quot;, 75000, 1987, 12, 15);        staff[1] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);        staff[2] &#x3D; new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15);        try (DataOutputStream out &#x3D; new DataOutputStream(new FileOutputStream(&quot;employee.dat&quot;))) &#123;            for (Employee e : staff)                writeData(out, e);        &#125;        try (RandomAccessFile in &#x3D; new RandomAccessFile(&quot;employee.dat&quot;, &quot;r&quot;)) &#123;            int n &#x3D; (int) (in.length() &#x2F; Employee.RECORD_SIZE);            Employee[] newStaff &#x3D; new Employee[n];            for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;&#x2F;&#x2F;                newStaff[i] &#x3D; new Employee();                in.seek(i * Employee.RECORD_SIZE);                newStaff[i] &#x3D; readData(in);            &#125;            for (Employee e:staff)&#123;                System.out.println(e);            &#125;        &#125;    &#125;    public static void writeData(DataOutput out, Employee e) throws IOException    &#123;        DataIO.writeFixedString(e.getName(), Employee.NAME_SIZE, out);        out.writeDouble(e.getSalary());        LocalDate hireDay &#x3D; e.getHireDay();        out.writeInt(hireDay.getYear());        out.writeInt(hireDay.getMonthValue());        out.writeInt(hireDay.getDayOfMonth());    &#125;    public static Employee readData(DataInput in) throws IOException    &#123;        String name &#x3D; DataIO.readFixedString(Employee.NAME_SIZE, in);        double salary &#x3D; in.readDouble();        int y &#x3D; in.readInt();        int m &#x3D; in.readInt();        int d &#x3D; in.readInt();        return new Employee(name, salary, y, m, d);    &#125;&#125;package randomAccess;import java.io.DataInput;import java.io.DataOutput;import java.io.IOException;public class DataIO &#123;    public static void writeFixedString(String s, int size, DataOutput out) throws IOException    &#123;        for(int i &#x3D; 0; i &lt; size; i++)&#123;            char ch &#x3D; 0;            if(i&lt;s.length())                ch &#x3D; s.charAt(i);            out.writeChar(ch);        &#125;    &#125;    public static String readFixedString(int size, DataInput in) throws IOException    &#123;        StringBuilder b &#x3D; new StringBuilder(size);        int i &#x3D; 0;        boolean more &#x3D; true;        while(more &amp;&amp; i&lt;size)&#123;            char ch &#x3D; in.readChar();            i++;            if (ch&#x3D;&#x3D;0) more &#x3D; false;            else b.append(ch);        &#125;        in.skipBytes(2*(size-i));        return b.toString();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">API java.io.RandomAccessFileRandomAccessFile(String file, String mode)RandomAccessFile(File file, String mode)long getFilePointer()返回文件指针的当前位置void seek(long pos)将文件指针设置到距文件开头pos个字节处long length()返回文件按照字节来度量的长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-zip文档"><a href="#3-3-zip文档" class="headerlink" title="3.3 zip文档"></a>3.3 zip文档</h3><p>zip文档以压缩格式存储了一个或多个文件，zip文档有一个头包含每个文件名字及所使用的压缩算法等信息，在Java中使用ZipInputStream来读入ZIP文档，如果需要浏览文档中的每个单独的项，getNextEntry方法就可以返回一个ZipEntry类型的对象 向ZipInputStream的getIuputStream方法传递该对象可以获取用于读取该项的输入流,然后调用closeEntry来读入下一项典型的通读ZIP文件的代码如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ZipInputSream zin &#x3D; new ZipInputStream(new FileInputSream(zipname));ZipEnery entry;while((entry &#x3D; zin.getNextEntry()) !&#x3D; null)&#123;    InputStream in &#x3D; zin.getInputStream(entry);    read the contents of in    zin.closeEntry();&#125;zin.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要写出到ZIP文件,使用ZipOutputStream,对于想要写入ZIP文件中的每一项,都应该创建一个ZipEntry对象,将文件名传递给ZipEntry的构造器,可以设置文件的日期和解压缩方法等参数,然后调用ZipOutputStream的putNextEntry方法来写出新文件,并将文件数据发送到ZIP输出流中,完成时调用closeEntry.代码框架如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FileOutputStream fout &#x3D; new FileOutputStream(&quot;test.zip&quot;);ZipOutputStream zout &#x3D; new ZipOutputStream(fout);for all files&#123;    ZipEntry ze &#x3D; new ZipEntry(filename);    zout.putNextEntry(ze);    send data to zout    zout.closeEntry();&#125;zout.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">API java.util.zip.ZipInputStreamZipInputStream(InputStream in)ZipEntry getNextEntry()void closeEntry()API java.util.zip.ZipOutputStreamZipOutputStream(OutputStream out)void putNextEntry(ZipEntry ze)void closeEntry()void setLevel(int level)设置后续的各个DEFLATED项的默认压缩级别void setMethod(int method)设置默认压缩算法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-操作文件"><a href="#4-操作文件" class="headerlink" title="4. 操作文件"></a>4. 操作文件</h2><p>Path接口和Files类封装了在用户机器上处理文件系统所需的所有功能。</p><h3 id="4-1-Path"><a href="#4-1-Path" class="headerlink" title="4.1 Path"></a>4.1 Path</h3><p>静态的Paths.get方法接受一个或多个字符串，并将他们用默认文件系统的路劲分隔符连接起来（类Unix文件系统是/,Windows是\），然后解析连接起来的结果，如果不是文件系统的合法路径就抛出InvalidPathException异常。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Path absolute &#x3D; Paths.get(&quot;\\home&quot;, &quot;harry&quot;)p.resolve(q)按照下列规则返回一个路径：-如果q是一个绝对路径，结果就是q-否则，将p后面跟着q作为结果resolve方法也可以直接接收一个字符串Path workPath &#x3D; basePath.resolve(&quot;work&quot;)resolveSibling通过解析指定路径的父路径产生其兄弟路径，如workPath是\\opt\\myapp\\workPath tempPath &#x3D; workPath.resolveSibling(&quot;temp&quot;)将创建\\opt\\myapp\\tempresolve的对立面是relativize，p.relativize(r)将产生路径q，而对q进行解析的结果正是r。如以、、home\\cay对目标\\home\\fred\\myprog进行相对化操作，将产生..\\fred\\myprog。normalize方法移除所有冗余的.和..,如规范化\\home\cay\\..\\fred\\.\\myprog将产生\\home\\cay\\fred\\myprog。toAbsolutePath方法将产生给定路径的绝对路径。绝对路径从根部件开始。Path类的其他有用的方法：Path p &#x3D; Paths.get(&quot;\\home&quot;, &quot;fred&quot;, &quot;myprog.properties&quot;);Path parent &#x3D; p.getParent(); &#x2F;&#x2F;  \\home\\fredPath file &#x3D; p.getFileName(); &#x2F;&#x2F; the path myprog.propertiesPath root &#x3D; p.getRoot();  &#x2F;&#x2F; the path \\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-读写文件"><a href="#4-2-读写文件" class="headerlink" title="4.2 读写文件"></a>4.2 读写文件</h3><p>Files类使得普通文件操作变得便捷。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">byte[] bytes &#x3D; Files.readAllBytes(path);  读取文件的所有内容String content &#x3D; new String(bytes, charset)以行序列读入：List&lt;String&gt; lines &#x3D; Files.readAllLines(path, charset);写出一个字符串到文件中：Files.write(path, content.getBytes(charset));将一个行的集合写出到文件中：Files.write(path, lines)处理较大的文件或是二进制文件，还是使用输入\输出流或者读入器\写出器：InputStream in &#x3D; Files.newInputStream(path)OutputStream out &#x3D; Files.newOutputStream(path)Reader in &#x3D; Files.newBufferedReader(path, charset)Writer out &#x3D; Files.newBufferedWriter(path, charset)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-创建文件和目录"><a href="#4-3-创建文件和目录" class="headerlink" title="4.3 创建文件和目录"></a>4.3 创建文件和目录</h3><pre class="line-numbers language-none"><code class="language-none">创建新目录可以调用Files.createDirectory(path);其中路径中除最后一个部件外，其他部分必须是已存在的。要创建路径中的中间目录，应该使用Files.createDirectories(path);使用下面的语句创建一个空文件：Files.createFile(path)如果文件已经存在，那么就会抛出异常。在给定位置或者系统指定位置创建临时文件或临时目录Path newPath &#x3D; Files.createTempFile(dir, prefix, suffix)Path newPath &#x3D; Files.createTempFile(prefixx, suffix)Path newPath &#x3D; Files.createTempDirectory(dir, prefix)Path newPath &#x3D; Files.createTempDirectory(prefix)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-复制移动和删除文件"><a href="#4-4-复制移动和删除文件" class="headerlink" title="4.4 复制移动和删除文件"></a>4.4 复制移动和删除文件</h3><pre class="line-numbers language-none"><code class="language-none">将文件从一个位置复制到另一个位置可以直接调用Files.copy(fromPath, toPath);移动文件可以调用Files.move(fromPath, toPath);如果目标路径已经存在那么移动或复制将失败，如果要覆盖已有的目标路径，可以使用REPLACE_EXISTING选项，要复制文件属性使用COPY_ATTRIBUTES选项。Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);可以将移动操作定义为原子性的，使用ATOMIC_MOVE选项来实现：Files.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);还可以将一个输入流复制到Path中，这表示将输入流存储到硬盘上，类似的可以将一个Path复制到输出流中，可以使用下面的调用：Files.copy(inputStream, toPath)Files.copy(fromPath, outputStream);删除文件可以调用Files.delete(path)如果文件不存在这个方法就会抛出异常，可以使用下面的方法：boolean deleted &#x3D; Files.deleteIfExists(path);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-获取文件信息"><a href="#4-5-获取文件信息" class="headerlink" title="4.5 获取文件信息"></a>4.5 获取文件信息</h3><pre class="line-numbers language-none"><code class="language-none">下面的静态方法都将返回一个boolean值，表示检查路径的某个属性的结果：existsisHiddenisReadable, isWritable, isExecutableisRegularFile, isDirectory, isSymbolicLinksize方法将返回文件的字节数long fileSize &#x3D; Files.size(path) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-访问目录中的项"><a href="#4-6-访问目录中的项" class="headerlink" title="4.6 访问目录中的项"></a>4.6 访问目录中的项</h3><pre class="line-numbers language-none"><code class="language-none">Files.list方法会返回一个可以读取目录中各个项的Stream&lt;Path&gt;对象，目录是被惰性读取的，这使得处理具有大量项的目录时更加高效。因为读取目录涉及需要关闭的系统资源，所以应该使用try块：try(Steam&lt;Path&gt; entris &#x3D; Files.list(pathToDirectory))&#123;    ...&#125;list方法不会进入子目录，为了处理目录中的所有子目录，需要使用File.walk方法。try(Stream&lt;Path&gt; entries &#x3D; Files.walk(pathToRoot))&#123;    visited in depth-first order&#125;使用Files.walk方法来将一个目录复制到另一个目录：Files.walk(source).forEach(p -&gt;&#123;    try    &#123;        Path q &#x3D; target.resolve(source.relativize(p));        if (Files.isDirectory(q))            Files.createDirectory(q);        else            Files.copy(p, q);    &#125;    catch (IOException ex)    &#123;        throw new UncheckedIOException(ex);    &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-7-使用目录流"><a href="#4-7-使用目录流" class="headerlink" title="4.7 使用目录流"></a>4.7 使用目录流</h3><pre class="line-numbers language-none"><code class="language-none">Files.walk方法会产生一个可以遍历目录中所有子孙的Stream&lt;Path&gt;对象。可以使用Files.newDirectoryStream，它产生一个DirectoryStream。它是Iterable的子接口，因此可以使用for循环。try (DirectoryStream&lt;Path&gt; entries &#x3D; Files.newDirectoryStream(dir))&#123;    for (Path entry:entries)        process entries&#125;（只遍历一级子目录）可以使用glob模式来过滤文件：try (DirectoryStream&lt;Path&gt; entries &#x3D; Files.newDirectoryStream(dir, &quot;*.java&quot;))Files.walkFileTree方法可以访问某个目录的所有子孙目录，可以较方便地实现删除目录树，详细内容参见《Java核心技术 卷Ⅱ》第二章P93。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-8-ZIP文件系统"><a href="#4-8-ZIP文件系统" class="headerlink" title="4.8 ZIP文件系统"></a>4.8 ZIP文件系统</h3><pre class="line-numbers language-none"><code class="language-none">下面的调用FileSystem fs &#x3D; FileSystem.newFileSystem(Paths.get(zipname), null);将建立一个文件系统，它包含ZIP文档中的所有文件。如果知道文件名，那么从ZIP文档中复制出这个文件就很容易：Files.copy(fs.getPath(sourceName), targetPath);其中fs.getPath对于任意文件系统来说都与Paths.get类似。要列出ZIP文档中的所有文件，可以遍历文件树：FileSystem fs &#x3D; FileSystems.newFileSystem(Paths.get(zipname), null);Files.walkFileTree(fs.getPath(&quot;&#x2F;&quot;), new SimpleFileVisitor&lt;Path&gt;()&#123;    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException    &#123;        System.out.println(file);        return FileVisitResult.CONTINUE;    &#125;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-内存映射文件"><a href="#5-内存映射文件" class="headerlink" title="5. 内存映射文件"></a>5. 内存映射文件</h2><h3 id="5-1-内存映射文件性能"><a href="#5-1-内存映射文件性能" class="headerlink" title="5.1 内存映射文件性能"></a>5.1 内存映射文件性能</h3><p>java.nio包使得内存映射变得十分简单，首先从文件获得一个通道（channel），通道是用于磁盘文件的一种抽象。然后通过调用FileChannel类的map方法从这个通道获得一个ByteBuffer。可以指定想要映射的文件区域和映射模式，一旦有了缓冲区，就可以使用ByteBuffer类的Buffer超类的方法读写数据了。</p><pre class="line-numbers language-none"><code class="language-none">FileChannel channel &#x3D; FileChannel.open(path, options);ByteBuffer buffer &#x3D; channel.map(FileChannel.MapMode.READ_ONLY, 0, length);...While (buffer.hasRemaining())&#123;    byte b &#x3D; buffer.get();    ...&#125;for (int i&#x3D;0; i&lt;buffer.limit(); i++)&#123;    byte b &#x3D; buffer.get(i);    ...&#125;读写字节数组：get(byte[] bytes)get(byte[], int offset, int length)其他一些方法用来读入在文件中存储为二进制的基本类型值：getIntgetLonggetShort...要向缓冲区写数字，使用：putIntputLongputShort在恰当的时机，以及当通道关闭时，会将这些修改写回到文件中。示例程序：package memoryMap;import java.io.BufferedInputStream;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.zip.CRC32;public class MemoryMapTest &#123;    public static long checksumInputStream(Path fielname) throws IOException    &#123;        try (InputStream in &#x3D; Files.newInputStream(fielname))        &#123;            CRC32 crc &#x3D; new CRC32();            int c;            while((c&#x3D;in.read()) !&#x3D; -1)                crc.update(c);            return crc.getValue();        &#125;    &#125;    public static long checksumBufferedInputStream(Path filename) throws IOException    &#123;        try (InputStream in &#x3D; new BufferedInputStream(Files.newInputStream(filename)))        &#123;            CRC32 crc &#x3D; new CRC32();            int c;            while((c&#x3D;in.read()) !&#x3D; -1)                crc.update(c);            return crc.getValue();        &#125;    &#125;    public static long checksumRandomAccessFile(Path filename) throws IOException    &#123;        try (RandomAccessFile file &#x3D; new RandomAccessFile(filename.toFile(), &quot;r&quot;))        &#123;            long length &#x3D; file.length();            CRC32 crc &#x3D; new CRC32();            for (long p &#x3D; 0; p &lt; length; p++)            &#123;                file.seek(p);                int c &#x3D; file.readByte();                crc.update(c);            &#125;            return crc.getValue();        &#125;    &#125;    public static long checksumMappedFile(Path filename) throws IOException    &#123;        try(FileChannel channel &#x3D; FileChannel.open(filename))        &#123;            CRC32 crc &#x3D; new CRC32();            int length &#x3D; (int) channel.size();            MappedByteBuffer buffer &#x3D; channel.map(FileChannel.MapMode.READ_ONLY, 0, length);            for (int p &#x3D; 0; p &lt; length; p++)            &#123;                int c &#x3D; buffer.get(p);                crc.update(c);            &#125;            return crc.getValue();        &#125;    &#125;    public static void main(String[] args) throws IOException    &#123;        System.out.println(&quot;Input Stream:&quot;);        long start &#x3D; System.currentTimeMillis();        Path filename &#x3D; Paths.get(args[0]);        long crcValue &#x3D; checksumInputStream(filename);        long end &#x3D; System.currentTimeMillis();        System.out.println(Long.toHexString(crcValue));        System.out.println((end-start) + &quot; milliseconds&quot;);        System.out.println(&quot;Buffered Input Stream:&quot;);        start &#x3D; System.currentTimeMillis();        crcValue &#x3D; checksumInputStream(filename);        end &#x3D; System.currentTimeMillis();        System.out.println(Long.toHexString(crcValue));        System.out.println((end-start) + &quot; milliseconds&quot;);        System.out.println(&quot;Input Stream:&quot;);        start &#x3D; System.currentTimeMillis();        crcValue &#x3D; checksumInputStream(filename);        end &#x3D; System.currentTimeMillis();        System.out.println(Long.toHexString(crcValue));        System.out.println((end-start) + &quot; milliseconds&quot;);        System.out.println(&quot;Input Stream:&quot;);        start &#x3D; System.currentTimeMillis();        crcValue &#x3D; checksumInputStream(filename);        end &#x3D; System.currentTimeMillis();        System.out.println(Long.toHexString(crcValue));        System.out.println((end-start) + &quot; milliseconds&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-缓冲区数据结构"><a href="#5-2-缓冲区数据结构" class="headerlink" title="5.2 缓冲区数据结构"></a>5.2 缓冲区数据结构</h3><p>在使用内存映射时可以使用更多的缓冲区来读写大小适度的信息块。<br>缓冲区是由具有相同类型的数值构成的数组，Buffer类是一个抽象类，它有众多的具体子类，包括ByteBuffer、CharBuffer、DoubleBuffer、IntBuffer、LongBuffer…<br>实际中最常用的是ByteBuffer、CharBuffer，每个缓冲区都具有：</p><ul><li>一个容量</li><li>一个读写位置，下一个值将在此进行读写</li><li>一个界限，超过它读写是没有意义的</li><li>一个可选的标记，用于重复一个读写操作</li></ul><p>假设我们有一个缓冲区，在一开始他的位置是0，界限等于容量。我们不断地调用put将值添加到这个缓冲区，当我们耗尽所有的数据或者写出的数据量达到容量大小时，就该切换到读入操作了。这时调用flip方法将界限设置到当前位置，并把位置复位到0，在remaining方法返回正数时（界限-位置）不断调用get，将缓冲区所有的值都读入之后，调用clean使缓冲区为下一次写循环做好准备。clean方法将位置复位到0，并将界限复位到容量。</p><p>要获取缓冲区，可以调用ByteBuffer.allocate或ByteBuffer.wrap这样的静态方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ByteBuffer buffer &#x3D; ByteBuffer.allocate(RECORD_SIZE);channel.read(buffer);channel.position(newpos);buffer.flip();channel.write(buffer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="2021/031116114.html"/>
      <url>2021/031116114.html</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Java的反射是指程序在运行期可以获取一个对象的所有信息。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>对于Java中的class，JVM在执行过程中动态加载，JVM在第一次读取到一种class类型时，就将其加载进内存，每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。住：这里的Class类型是一个名叫Class的类。</p><p>例如当JVM加载String类时，它首先读取String.class文件到内存，然后为String类创建一个Class实例并关联起来：</p><p><code>Class cls = new Class(String);</code></p><p>这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。</p><p>一个Class实例包含了对于class的所有完整信息。因此只要获取了某个Class实例，就可以获取其对应的class的所有信息。这种方法就叫做反射。</p><h3 id="获取Class实例"><a href="#获取Class实例" class="headerlink" title="获取Class实例"></a>获取Class实例</h3><p>获取一个class的Class实例有三个方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;方法一：Class cls &#x3D; String.class;&#x2F;&#x2F;方法二：实例的getClass()String s &#x3D; &quot;Hello&quot;;Class cls &#x3D; s.getClass();&#x2F;&#x2F; 方法三：类名Class cls &#x3D; Class.forName(&quot;java.lang.String&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从Class实例获取信息"><a href="#从Class实例获取信息" class="headerlink" title="从Class实例获取信息"></a>从Class实例获取信息</h3><p>获取基本信息如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class cls &#x3D; String.class;cls.getName();cls.getSimpleName();cls.getPackage();cls.isInterface();cls.isEnum();cls.isArray();cls.isPrimitive();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所用到的class全部加载到内存，而是第一次用到class时才加载。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main&#123;    public void main(String[] args)&#123;        if (args.length &gt; 0)&#123;            create(args[0]);        &#125;    &#125;    static void create(String name) &#123;        Person p &#x3D; new Person(name);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行Main.java时，由于用到了Main，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。这就是JVM动态加载class的特性。</p><p>利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LogFactory factory &#x3D; null;if (isClassPresent(&quot;org.apache.logging.log4j.Logger&quot;))&#123;    factory &#x3D; createLog4j();&#125;else &#123;    factory &#x3D; createJdkLog();&#125;boolean isClassPresent(String name) &#123;    try &#123;        CLass.forName(name);        return true;    &#125;    catch (Exception e)&#123;        return false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JVM为每个加载的class及Interface创建了对应的Class实例来保存class及Interface的所有信息；</p><p>获取一个class对应的Class实例后，就可以获取该class的所有信息；</p><p>通过Class实例获取class信息的方法称为反射；</p><p>JVM总是动态加载class，可以在运行期通过条件控制加载class。</p><h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><p>Class类提供了几种方法来获取字段：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Field getField(name) &#x2F;&#x2F; 根据字段名获取某个public的field(包括父类)Field getDeclaredField(name) &#x2F;&#x2F; 根据字段名获取当前类的某个field（不包括父类）Field[] getFields(): &#x2F;&#x2F;获取所有的public的field(包括父类)Field[] getDeclaredFields(): &#x2F;&#x2F;获取当前类的所有field（不包括父类）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例程序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main&#123;    public static void main(String[] args) throws Exception&#123;        Class stdClass &#x3D; Student.class;        System.out.println(stdClass.getField(&quot;score&quot;));        System.out.println(stdClass.getField(&quot;name&quot;));        System.out.println(stdClass.getDeclaredField(&quot;grade&quot;));    &#125;&#125;class Student extends Person &#123;    public int score;    private int grade;&#125;class Person&#123;    public String name;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个Field对象包含了一个字段的所有信息：</p><ul><li>getName():返回字段名称，例如，”name”;</li><li>getType(): 返回字段类型，也是一个Class实例，例如String.class;</li><li>getModifiers(): 返回字段的修饰符，它是一个int，不同的bit表示不同的含义。</li></ul><p>以String字段的value字段为例，它的定义是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class String &#123;    private final byte[] value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们用反射获取该字段的信息，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Field f &#x3D; String.class.getDeclaredDield(&quot;value&quot;);f.getName();    &#x2F;&#x2F;valuef.getType();    &#x2F;&#x2F;class [B 表示byte[]类型int m &#x3D; f.getModifiers();Modifier.isFinal(m);    &#x2F;&#x2F;trueModifier.isPublic(m);   &#x2F;&#x2F;falseModifier.isProtected(m);    &#x2F;&#x2F;falseModifier.isPrivate(m);  &#x2F;&#x2F;trueModifier.isStatic(m);   &#x2F;&#x2F;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h3><p>利用反射拿到字段的一个Field实例后还可以拿到该实例对应的该字段的值。</p><p>例如，对于一个Person实例，我们可以先拿到name字段对应的Field，再获取这个实例的name字段的值：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Fieldpublic class Main&#123;    public static void main(String[] args) throws Exception &#123;        Object p &#x3D; new Person(&quot;Xiao Ming&quot;);        Class c &#x3D; p.getClass();        Field f &#x3D; c.getDeclaredField(&quot;name&quot;);        Object value &#x3D; f.get(p);        System.out.println(value);    &#125;&#125;class Person &#123;    private String name;    public Person(String name) &#123;        this.name &#x3D; name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码利用Field.get(Object)获取指定实例的指定字段的值。但是上述代码运行时将报错，因为Main类无法访问Person类的private字段。可以将private改成public或者，在调用<code>Object value = f.get(p);</code>之前，先写一句：</p><p><code>f.setAccessible(true);</code></p><p>调用Field.setAccessible(true)的意思是，别管这个字段是不是public，一律允许访问。</p><h3 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h3><p>通过Field.set(Object, Object)实现，第一个Object是指定的实例，第二个Object是待修改的值。</p><p>同样的，修改非public字段，需要首先调用setAccessible(true)。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java的反射API提供的Field类封装了字段的所有信息：</p><p>通过Class实例的方法可以获取Field实例：getField(),getFields(), getDeclaredField(), getDeclaredFields();</p><p>通过Field实例可以获取字段信息：getName(), getType(), getModifiers();</p><p>通过Field实例可以读取或者设置某个对象的字段，如果存在访问限制，要先调用setAccessible(true)来访问非public字段。</p><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>Class类提供了以下几种方法来获取Method：</p><ul><li>Method getMethod(name, Class…): 获取某个public的Method（包括父类）</li><li>Method getDeclaredMethod(name, Class…): 获取当前类的某个Method(不包括父类)</li><li>Method[] getMethods(): 获取所有public的Method(包括父类)</li><li>Method[] getDeclaredMethods(): 获取当前类的所有Method(不包括父类)</li></ul><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class stdClass &#x3D; Student.class;        &#x2F;&#x2F; 获取public方法getScore，参数为String        System.out.println(stdClass.getMethod(&quot;getScore&quot;, String.class));        &#x2F;&#x2F; 获取继承的public方法getName，无参数        System.out.println(stdClass.getMethod(&quot;getName&quot;));        &#x2F;&#x2F; 获取private方法getGrade，参数为int        System.out.println(stdClass.getDeclaredMethod(&quot;getGrade&quot;, int.class));    &#125;&#125;class Student extends Person &#123;    public int getScore(String type) &#123;        return 99;    &#125;    private int getGrade(int year) &#123;        return 1;    &#125;&#125;class Person &#123;    public String getName() &#123;        return &quot;Person&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上诉代码首先获取Student的Class实例，然后，分别获取public方法、继承的public方法以及private方法。返回Method对象。</p><p>一个Method对象包含一个方法的所有信息：</p><ul><li>getName(): 返回方法名称，例如：”getScore”;</li><li>getReturnType()：返回方法返回值类型，也是一个Class实例，例如String.class;</li><li>getParameterTypes():返回方法的参数类型，是一个Class数组，例如：{String.class, int.class};</li><li>getModifiers():返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</li></ul><h3 id="调用方法-1"><a href="#调用方法-1" class="headerlink" title="调用方法"></a>调用方法</h3><p>当获取一个Method对象时，就可以对它进行调用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflection.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        String s &#x3D; &quot;Hello World&quot;;        Method m &#x3D; s.getClass().getMethod(&quot;substring&quot;, int.class);        String r &#x3D; (String) m.invoke(s, 6);        System.out.println(r);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，后面的可变参数与方法参数一致。</p><h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。以Integer.parseInt(String)为例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Method m &#x3D; Integer.class.getMethod(&quot;parseInt&quot;, String.class);        Integer n &#x3D; (Integer) m.invoke(null, &quot;12345&quot;);        System.out.println(n);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调用非public方法"><a href="#调用非public方法" class="headerlink" title="调用非public方法"></a>调用非public方法</h3><p>和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()方法获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Person p &#x3D; new Person();        Method m &#x3D; p.getClass().getDeclaredMethod(&quot;setName&quot;, String.class);        m.setAccessible(true);        m.invoke(p, &quot;Bob&quot;);        System.out.println(p.name);    &#125;&#125;class Person &#123;    String name;    private void setName(String name) &#123;        this.name &#x3D; name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>考察这样一种情况：一个Person类定义了hello()方法,并且它的子类Student也覆写了hello()方法，那么，从Person.class获取的Method，作用于Student实例时，调用的方法是哪个？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Methodpublic class Main &#123;    public static void main(String[] args) throws Exception &#123;        Method h &#x3D; Person.class.getMethod(&quot;hello&quot;);        h.invoke(new Student());    &#125;&#125;class Person &#123;    public void hello() &#123;        System.out.println(&quot;Person: hello&quot;);    &#125;&#125;class Student extends Person &#123;    public void hello() &#123;        System.out.println(&quot;Student: hello&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的结果是：Student:hello,因此使用反射调用方法时，仍然遵循多态原则，上述的反射代码实际上相当于：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person p &#x3D; new Student();p.hello();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Java的反射API提供的Method对象封装了方法的所有信息：</p><p>通过Class实例的方法可以获取Method实例：getMethod(),getMethods(),getDeclaredMethod(),getDeclaredMethods();</p><p>通过Method实例可以获取方法信息：getName(), getReturnType(), getParameterTypes(), getModifiers();</p><p>通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object… parameters);</p><p>通过设置setAccessible(true)来访问非public方法；</p><p>通过反射调用方法时，仍遵循多态原则。</p><h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>通常是用new来创建新的实例，如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p><p><code>Person p = Person.class.newInstance()</code></p><p>但是其局限是只能调用该类的public无参数构造方法。</p><p>为了调用任意的构造方法，Java的反射API提供了COnstructor对象，它包括一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，其调用结果总是返回一个实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Constructor;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Constructor cons1 &#x3D; Integer.class.getConstructor(int.class);        Integer n1 &#x3D; (Integer) cons1.newInstance(123);        System.out.println(n1);        Constructor cons2 &#x3D; Integer.class.getConstructor(String.class);        Integer n2 &#x3D; (Integer) cons2.newInstance(&quot;123&quot;);        System.out.println(n2);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过Class实例获取Constructor的方法如下：</p><ul><li>getConstructor(Class…): 获取某个public的Constructor；</li><li>getDeclaredConstructor(Class…): 获取某个COnstructor；</li><li>getConstructors(): 获取所有public的Constructor；</li><li>getDeclaredConstructors(): 获取所有COnstructor。</li></ul><p>调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>Constructor对象封装了构造方法的所有信息；</p><p>通过CLass实例的方法可以获取Constructor实例：getConstructor(), getConstructors(), getDeclaredConstructor(), getDeclaredConstructors();</p><p>通过Constructor实例可以创建一个实例对象：newInstance(Object… parameters);通过设置setAccessible(true)来访问非public构造方法。</p><h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><h3 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a>获取父类的Class</h3><p>有了Class实例，还可以获取它的父类的Class：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class i &#x3D; Integer.class;        Class n &#x3D; i.getSuperclass();        System.out.println(n);        Class o &#x3D; n.getSuperclass();        System.out.println(o);        System.out.println(o.getSuperclass());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a>获取interface</h3><p>由于一个类可能出现一个或多个接口，通过Class我们就可以查询到实现的接口类型。例如查询Integer实现的接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class s &#x3D; Integer.class;        Class[] is &#x3D; s.getInterfaces();        for (Class i : is) &#123;            System.out.println(i);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。</p><p>如果一个类没有实现任何interface，那么getInterfaces()返回空数组。</p><p>对interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces():</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(java.io.Closeable.class.getSuperclass());    &#x2F;&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>当我们判断一个实例是否是某个类型的时候，正常情况下，使用instanceof操作符：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object n &#x3D; Integer.valueOf(123);boolean isDouble &#x3D; n instanceof Double; &#x2F;&#x2F;falseboolean isInteger &#x3D; n instanceof Integer;   &#x2F;&#x2F;trueboolean isNumber &#x3D; n instanceof Number; &#x2F;&#x2F;trueboolean isSerializable &#x3D; n instanceof java.io.Serializable; &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom():</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Integer.class.isAssignableFrom(Integer.class);  &#x2F;&#x2F;true因为Integer可以赋值给IntegerNumber.class.isAssignableFrom(Integer.class); &#x2F;&#x2F;true因为Integer可以赋值给Number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>通过Class对象可以获取继承关系：</p><ul><li>CLass getSuperclass(): 获取父类类型；</li><li>Class[] getInterfaces(): 获取当前类实现的所有接口</li></ul><p>通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java中interface类型的变量总是通过向上转型并指向某个实例的：</p><p><code>CHarSequence cs = new StringBuilder();</code></p><p>有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？</p><p>这是可能的，因为Java标准库提供了一种动态代理（dynamic proxy）的机制:可以在运行期动态创建某个interface的实例。</p><p>所谓动态代理，和静态代理是相对应的。我们来看看静态代码怎么写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 定义接口public interface Hello &#123;    void morning(String name);&#125;&#x2F;&#x2F; 编写实现类public class HelloWorld implements Hello &#123;    public void morning(String name) &#123;        System.out.println(&quot;Good morning, &quot; + name);    &#125;&#125;&#x2F;&#x2F; 创建实例，转型为接口并调用Hello hello &#x3D; new HelloWorld();hello.morning(&quot;Bob&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是我们通常编写代码的方式，还有一种方式是动态代码，我们仍然定义了接口Hello，但是我们不去编写实现类，而是通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello对象。这种没有实现类但是在运行期间动态创建了一个接口对象的方式，我们称之为动态代码。JDK提供的动态创建接口对象的方式，就叫做动态代理。</p><p>一个简单的动态代理实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.raflect.Proxy;public class Main &#123;    public static void main(String[] args) &#123;        InvocationHandler handler &#x3D; new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(method);                if (method.getName().equals(&quot;morning&quot;)) &#123;                    System.out.println(&quot;Good morning, &quot; + args[0]);                &#125;                return null;            &#125;        &#125;;        Hello hello &#x3D; (Hello) Proxy.newProxyInstance(            Hello.class.getClassLoader(),            new Class[] &#123;Hello.class&#125;,            handler);        hello.morning(&quot;Bob&quot;);    &#125;&#125;interface Hello &#123;    void morning(String name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在运行期动态创建一个interface实例的方法如下：</p><ol><li><p>定义一个InvocationHandler实例，它负责实现接口的方法调用；</p></li><li><p>通过Proxy.newProxyInstance()创建interface实例，它需要三个参数：</p><ol><li>使用的ClassLoader,通常就是接口类的ClassLoader；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的InvocationHandler实例。</li></ol></li><li><p>将返回的Object强制转型为接口。</p></li></ol><p>动态代理实际上是JVM在运行期间动态创建Class字节码并加载的过程，把上面的动态代理改写为静态实现类大概是这样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloDynamicProxy implements Hello &#123;    InvocationHandler handler;    public HelloDynamicProxy(InvocationHandler handler) &#123;        this.handler &#x3D; handler;    &#125;    public void morning(String name) &#123;        handler.invoke(            this,            Hello.class.getMethod(&quot;morning&quot;, String.class),            new Object[] &#123; name &#125;        );    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>Java标准库提供了动态代理功能，允许在运行期间动态创建一个接口的实例；</p><p>动态代理是通过Proxy创建代理对象，然后将接口方法代理给InvocationHandler完成的。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="2021/013016113.html"/>
      <url>2021/013016113.html</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1. 什么是泛型"></a>1. 什么是泛型</h2><p>首先观察下Java标准库的ArrayList，它可以看成变长数组，因为用起来比数组更加方便。实际上ArrayList内部就是一个Object[]数组，配合存储一个当前分配的长度，就可以充当变长数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayList&#123;    private Object[] array;    private int size;    public void add(Object e)&#123;...&#125;    public void remove(int index)&#123;...&#125;    public Object get(int index)&#123;...&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果用以上的ArrayList存储String类型，会有这么几个缺点：</p><ul><li>需要强制类型转换</li><li>不方便，易出错</li></ul><p>如代码需要这样写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList list &#x3D; new ArrayList();list.add(&quot;Hello&quot;);&#x2F;&#x2F; 获取到Object，必须强制转换为StringString first &#x3D; (String)list.get(0);&#x2F;&#x2F; 容易出现ClassCastException，因为容易&quot;误转型&quot;list.add(new Interger(123));String second &#x3D; (String)list.get(1);    &#x2F;&#x2F;ClassCastException<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要解决上述问题，可以为String单独编写一个ArrayList：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StringArrayList&#123;    private String[] array;    private int size;    public void add(String e)&#123;...&#125;    public void remove(int index)&#123;...&#125;    public String get(int index)&#123;...&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，存入的必须是String，取出来的也一定是String，然而问题是如果要存储Interger，还需要为Interger编写一个ArrayList。为其他的class也需要单独编写一种ArrayList，这显然是不可能的。</p><p>为了解决这个问题，必须把ArrayList变成一种模板：ArrayList&lt;T&gt;，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayList&lt;T&gt;&#123;    private T[] array;    private int size;    public void add(T e)&#123;...&#125;    public void remove(int index)&#123;...&#125;    public T get(int index)&#123;...&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>T可以是任何class，这样就实现了编写一次模板，可以创建任意类型的ArrayList：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList&lt;String&gt; strList &#x3D; new ArrayList&lt;&gt;();ArrayList&lt;Float&gt; floatList &#x3D; new ArrayList&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由编译器针对类型进行检查，保证了类型安全。</p><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>在Java标准库中的ArrayList&lt;T&gt;实现了List&lt;T&gt;接口，它可以向上转型为List&lt;T&gt;：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayList&lt;T&gt; implements List&lt;T&gt;&#123;    ...&#125;List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即类型ArrayList&lt;T&gt;可以向上转型为List&lt;T&gt;。</p><p>不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;，这是因为：将一个ArrayList&lt;Integer&gt;对象转型为ArrayList&lt;Number&gt;后，就可以向数组中添加Float类型，但是ArrayList&lt;Number&gt;和ArrayList&lt;Integer&gt;指向同一个对象，即ArrayList&lt;Interger&gt;类型，它不可能接收Float类型，所以在获取Integer的时候将产生ClassCastException。编译器为了避免这种错误，根本就不允许把ArrayList&lt;Integer&gt;转型为ArrayList&lt;Number&gt;。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>泛型就是编写模板代码来适应任意类型；<br>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；<br>注意泛型的继承关系：可以把ArrayList&lt;T&gt;向上转型为List&lt;Integer&gt;，但不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;。</p><h2 id="2-使用泛型"><a href="#2-使用泛型" class="headerlink" title="2. 使用泛型"></a>2. 使用泛型</h2><p>使用ArrayList时，如果不定义泛型类型时，泛型类型实际上就是Object:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 编译器警告List list &#x3D; new ArrayList();list.add(&quot;Hello&quot;);list.add(&quot;World&quot;);String first &#x3D; (String) list.get(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时只能把&lt;T&gt;作为Object使用，没有发挥泛型的优势。</p><p>定义泛型类型&lt;String&gt;后，List&lt;T&gt;的泛型接口变为强类型List&lt;String&gt;:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 无编译器警告：List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();list.add(&quot;Hello&quot;);list.add(&quot;World&quot;);&#x2F;&#x2F; 无强制转换String first &#x3D; list.get(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>除了ArrayList&lt;T&gt;使用了泛型，还可以在接口中使用泛型。例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable&lt;T&gt;这个泛型接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Comparable&lt;T&gt;&#123;    int compareTo(T o);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以直接对String数组进行排序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class Main&#123;    public static void main(String[] args)&#123;        String[] ss &#x3D; new String[] &#123;&quot;Orange&quot;, &quot;Apple&quot;, &quot;Pear&quot;&#125;;        Arrays.sort(ss);        System.out.println(Arrays.toString(ss));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为String本身已经实现了Comparable&lt;String&gt;接口。如果换成我们自定义的Person类试试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrayspublic class Main&#123;    public static void main(String[] args)&#123;        Person[] ps &#x3D; new Person[] &#123;            new Person(&quot;Bob&quot;, 61);            new Person(&quot;Alice&quot;, 88);            new Person(&quot;Lily&quot;, 75);        &#125;;        Arrays.sort(ps);        System.out.println(Arrays.toString(ps));    &#125;&#125;class Person&#123;    String name;    int score;        Person(String name, int score)&#123;        this.name &#x3D; name;        this.score &#x3D; score;    &#125;    public String toString()&#123;        return this.name + &quot;,&quot; + this.score;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序会得到ClassCastException,即无法将Person转型为Comparable。需要让Person实现Comparable&lt;T&gt;接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrayspublic class Main&#123;    public static void main(String[] args)&#123;        Person[] ps &#x3D; new Person[] &#123;            new Person(&quot;Bob&quot;, 61);            new Person(&quot;Alice&quot;, 88);            new Person(&quot;Lily&quot;, 75);        &#125;;        Arrays.sort(ps);        System.out.println(Arrays.toString(ps));    &#125;&#125;class Person&#123;    String name;    int score;        Person(String name, int score)&#123;        this.name &#x3D; name;        this.score &#x3D; score;    &#125;    public int compareTo(Person other)&#123;        return this.name.compareTo(other.name);    &#125;    public String toString()&#123;        return this.name + &quot;,&quot; + this.score;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>使用泛型时将泛型参数&lt;T&gt;转换为需要的class类型，例如：ArrayList&lt;String&gt;，ArrayList&lt;Number&gt;等；</p><p>可以省略编译器能自动推断出的类型，如：List&lt;String&gt; list = new ArrayList&lt;&gt;();</p><p>不指定泛型类型参数时，编译器会给出警告，且只能将&lt;T&gt;视为Object类型。</p><p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p><h2 id="3-编写泛型"><a href="#3-编写泛型" class="headerlink" title="3. 编写泛型"></a>3. 编写泛型</h2><p>可以按照以下步骤来编写一个泛型类。<br>首先，按照某种类型，如：String，来编写类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&#123;    private String first;    private String last;    public Pair(String first, String last)&#123;        this.first &#x3D; first;        this.last &#x3D; last;    &#125;    public String getFirst()&#123;        return first;    &#125;    public String getLast()&#123;        return last;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后标记所有的特定类型，这里是String，将String替换为T，并声明&lt;T&gt;:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T&gt;&#123;    private T first;    private T last;    public Pair(T first, T last)&#123;        this.first &#x3D; first;        this.last &#x3D; last;    &#125;    public T getFirst()&#123;        return first;    &#125;    public T getLast()&#123;        return last;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>编写泛型类型时，要特别注意，泛型类型&lt;T&gt;不能用于静态方法。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T&gt; &#123;    private T first;    private T last;    public Pair(T first, T last) &#123;        this.first &#x3D; first;        this.last &#x3D; last;    &#125;    public T getFirst()&#123;...&#125;    public T getLast()&#123;...&#125;    &#x2F;&#x2F; 对静态方法使用&lt;T&gt;    public static Pair&lt;T&gt; create(T first, T last)&#123;        return new Pair&lt;T&gt;(first, last);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码会导致编译错误，无法在静态方法create()的方法参数和返回类型上使用泛型类型T。在static修饰符后面加一个&lt;T&gt;，编译就能通过，但实际上，这个&lt;T&gt;和Pair&lt;T&gt;类型的&lt;T&gt;已经没有任何关系了，而是声明了一个泛型方法。<br>对于静态方法，可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的create()静态方法，我们应该把它改为另一种泛型类型，例如，&lt;K&gt;:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T&gt; &#123;    private T first;    private T last;    public Pair(T first, T last) &#123;        this.first &#x3D; first;        this.last &#x3D; last;    &#125;    public T getFirst() &#123;...&#125;    public T getLast() &#123;...&#125;    &#x2F;&#x2F; 静态泛型方法应该使用其他类型区分    public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) &#123;        return new Pair&lt;K&gt;(first, last);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样才能清楚地将静态方法的泛型类型与实例类型的泛型类型区分开。</p><h3 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h3><p>泛型可以定义多种类型，如我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;T, K&gt;:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T, K&gt; &#123;    private T first;    private K last;    public Pair(T first, K last) &#123;        this.first &#x3D; first;        this.last &#x3D; last;    &#125;    public T getFirst(); &#123;...&#125;    public K getLast(); &#123;...&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的时候，需要指出两种类型：<br>Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(“test”, 12);</p><p>Java标准库的Map&lt;K, V&gt;就是使用两种泛型类型的例子。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>编写泛型时，需要定义泛型类型&lt;T&gt;;</p><p>静态方法不能引用泛型类型&lt;T&gt;,必须定义其他类型（如&lt;K&gt;）来实现静态泛型方法；</p><p>泛型可以同时定义多种类型，例如Map&lt;K, V&gt;。</p><h3 id="补充（泛型方法的概念）"><a href="#补充（泛型方法的概念）" class="headerlink" title="补充（泛型方法的概念）"></a>补充（泛型方法的概念）</h3><p>泛型类的对象实例化后，其类型就固定了，那么类中的方法只能接受该类型的参数，泛型方法就是则可以操作不同的类型。见下例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Demo&lt;T&gt;&#123;    public void show(T t)&#123;        System.out.println(&quot;show: &quot; + t);    &#125;    public void print(T t)&#123;        System.out.println(&quot;print: &quot; + t);    &#125;&#125;Demo&lt;Integer&gt; d &#x3D; new Demo&lt;Integer&gt;();d.show(new Integer(4)); &#x2F;&#x2F;okd.print(&quot;hello&quot;);       &#x2F;&#x2F;error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为实例化d对象时，其类型是Integer,所以调用d.print(“hello”)会报错。</p><p>使用泛型方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Demo&lt;T&gt;&#123;    public void show(T t)&#123;        System.out.println(&quot;show: &quot; + t);    &#125;    public &lt;Q&gt; void print(Q q)&#123;        System.out.println(&quot;print:&quot; + q);    &#125;&#125;Demo&lt;Integer&gt; d &#x3D; Demo&lt;Integer&gt;();d.show(new Integer(4));d.print(&quot;hello&quot;)    &#x2F;&#x2F;ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-擦拭法"><a href="#4-擦拭法" class="headerlink" title="4. 擦拭法"></a>4. 擦拭法</h2><p>Java语言的泛型实现方式是擦拭法，所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p><p>例如，我们编写一个泛型类Pair&lt;T&gt;，这是编译器看到的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T&gt; &#123;    private T first;    private T last;    public Pair(T first, T last) &#123;        this.first &#x3D; first;        this.last &#x3D; last;    &#125;    public T getFirst() &#123;        return first;    &#125;    public T getLast() &#123;        return last;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair &#123;    private Object first;    private Object last;    public Pair(Object first, Object last) &#123;        this.first &#x3D; first;        this.last &#x3D; last;    &#125;    public Object getFirst() &#123;        return first;    &#125;    public Object getLast() &#123;        return last;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，Java使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型&lt;T&gt;视为Object；</li><li>编译器根据&lt;T&gt;实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Pair&lt;String&gt; p &#x3D; new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);String first &#x3D; p.getFirst();String last &#x3D; p.getLast();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而虚拟机执行的代码并没有泛型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Pair p &#x3D; new Pair(&quot;Hello&quot;, &quot;world&quot;);String first &#x3D; (String) p.getFirst();String last &#x3D; (String) p.getLast();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</p><h3 id="Java泛型的局限"><a href="#Java泛型的局限" class="headerlink" title="Java泛型的局限"></a>Java泛型的局限</h3><p><strong>&lt;T&gt;不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型。</strong></p><p><strong>无法取得带泛型的Class。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main &#123;    public static void main(String[] args) &#123;        Pair&lt;String&gt; p1 &#x3D; new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);        Pair&lt;Integer&gt; p2 &#x3D; new Pair&lt;&gt;(123, 456);        Class c1 &#x3D; p1.getClass();        Class c2 &#x3D; p2.getClass();        System.out.println(c1 &#x3D;&#x3D; c2);   &#x2F;&#x2F;true        System.out.println(c1 &#x3D;&#x3D; Pair.class);   &#x2F;&#x2F;true    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部是Pair&lt;Object&gt;。</p><p><strong>无法判断带泛型的类型</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Pair&lt;Integer&gt; p &#x3D; new Pair&lt;&gt;(12, 34);if (p instanceof Pair&lt;Integer&gt;) &#123;&#125;   &#x2F;&#x2F; Compile error;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原因和上面一样，并不存在Pair&lt;Integer&gt;.class,而只有唯一的Pair.class。</p><p><strong>不能实例化T类型</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T&gt; &#123;    private T first;    private T last;    public Pair() &#123;        &#x2F;&#x2F; compile error        first &#x3D; new T();        last &#x3D; new T();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码无法通过编译，因为构造方法中的<code>new T()</code>,擦拭后变成了<code>new Object()</code>。这样一来创建new Pair&lt;String&gt;()就变成了Object，显然编译器要阻止这种类型不对的代码。</p><p>要实例化T类型，我们必须借助额外的Class&lt;T&gt;参数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T&gt; &#123;    private T first;    private T last;    public Pair(Class&lt;T&gt; clazz) &#123;        first &#x3D; clazz.newInstance();        last &#x3D; clazz.newInstance();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码借助Class&lt;T&gt;参数并通过反射来实例化T类型，使用的时候，也必须传入Class&lt;T&gt;。例如：</p><p><code>Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class)</code></p><p>因为传入了Class&lt;String&gt;的实例，所以我们借助String.class就可以实例化String类型。</p><p><strong>不恰当的覆写方法</strong></p><p>有时候，一个看似正确定义的方法会无法通过编译。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T&gt; &#123;    public boolean equals(T t) &#123;        return this &#x3D;&#x3D; t;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为，定义的equals(T t)方法实际上会被擦除成equals(Object t),而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>换个方法名，避开与Object.equals(Object)的冲突就可以成功编译：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Pair&lt;T&gt; &#123;    public boolean same(T t)&#123;        return this &#x3D;&#x3D; t;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类，例如父类的类型是Pair&lt;Integer&gt;,子类的类型是IntPair，可以这么继承：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IntPair extends Pair&lt;Integer&gt; &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用的时候，因为子类IntPair并没有泛型类型，所以，正常使用即可：</p><p><code>IntPair ip = new IntPair(1, 2);</code></p><p>我们无法获取Pair&lt;T&gt;的T类型，即给定一个变量Pair&lt;Integer&gt; p，无法从p中获取到Integer类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型T（对IntPair来说，也就是Integer类型）保存到子类的class文件中，不然编译器就不知道IntPair只能存储Integer这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型Integer。获取父类的泛型类型代码比较复杂：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;public class Main &#123;    public static void main(String[] args) &#123;        Class&lt;Integer&gt; clazz &#x3D; IntPair.class;        Type t &#x3D; clazz.getGenericSuperClass();        if (t instanceof ParameterizedType) &#123;            ParameterizedType pt &#x3D; (ParameterizedType) t;            Type[] types &#x3D; pt.getActualTypeArguments(); &#x2F;&#x2F;可能有多个泛型类型            Type firstType &#x3D; types[0];            CLass&lt;?&gt; typeClass &#x3D; (Class&lt;?&gt;) firstType;            System.out.println(typeClass);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为引入了泛型，所以只用Class来标识类型已经不够了。实际上，java的类型系统包括：</p><pre class="line-numbers language-none"><code class="language-none">Type:    Class    ParameterizedType    GenericArrayType    WildcardType<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>java的泛型是用擦拭法实现的</p><p>擦拭法决定了泛型&lt;T&gt;:</p><ul><li>不能是基本类型，例如：int；</li><li>不能获取带泛型类型的Class，例如：Pair&lt;String&gt;.class;</li><li>不能判断带泛型类型的类型，例如：x instanceof Pair&lt;String&gt;;</li><li>不能实例化T类型，例如：new T();</li></ul><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>;<br>子类可以获取父类的泛型类型&lt;T&gt;。</p><h2 id="5-extends通配符"><a href="#5-extends通配符" class="headerlink" title="5. extends通配符"></a>5. extends通配符</h2><p>前面已经讲过泛型的继承关系：Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类。</p><p>假设我们针对Pair&lt;Number&gt;类型写了一个静态方法，它的参数类型是Pair&lt;Number&gt;:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PairHelper &#123;    static int add(Pair&lt;Number&gt; p) &#123;        Number first &#x3D; p.getFirst();        Number last &#x3D; p.getLast();        return first.intValue() + last.intValue();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码可以正常编译，使用时，传入：</p><p><code>int sum = PairHelper.add(new Pair&lt;Number&gt;(1, 2));</code></p><p>传入的类型是Pair&lt;Number&gt;,实际参数类型是(Integer, Integer)。</p><p>假设我们传入Pair&lt;Integer&gt;:</p><p><code>int n = PairHelper.add(new Pair&lt;Integer&gt;(1, 2));</code></p><p>会得到编译错误：<code>Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;</code></p><p>因为Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类，因此add(Pair&lt;Number&gt;)不接受参数类型Pair&lt;Integer&gt;。</p><p>但是传入Pair&lt;Integer&gt;完全符合代码内部的要求：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Number first &#x3D; p.getFirst();Number last &#x3D; p.getLast();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际类型是Integer,引用类型是Number。</p><p>有没有办法使得方法参数接受Pair&lt;Integer&gt;, 可以使用Pair&lt;? extends Number&gt;使得方法接受所有泛型类型为Number或Number子类的Pair类型。把代码改写如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Public class Main&#123;    public static void main(String[] args)&#123;        Pair&lt;Integer&gt; p &#x3D; new Pair&lt;&gt;(1, 2);        int n &#x3D; add(p);        System.out.println(n);    &#125;    static int add(Pair&lt;? extends Number&gt; p)&#123;        Number first &#x3D; p.getFirst();        Number last &#x3D; p.getLast();        return first.intValue() + last.intValue();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用&lt;? extends Number&gt;的泛型定义称为上界通配符，即把泛型类型T的上界限定在Number了。</p><p>再来看下Pair&lt;T&gt;的set方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main&#123;    public static void main(String[] args)&#123;        Pair&lt;Integer&gt; p &#x3D; new Pair&lt;&gt;(1, 2);        int n &#x3D; add(p);        System.out.println(n);    &#125;    static int add(Pair&lt;? extends Number&gt; p)&#123;        Number first &#x3D; p.getFirst();        Number last &#x3D; p.getLast();        p.setFirst(new Integer(first.intValue() + 100));        p.setLast(new Integer(last.intValue() + 100));        return p.getFirst().intValue() + p.getLast().intValue();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行时将得到一个编译错误，原因在于擦拭法，如果我们传入的p是Pair&lt;Double&gt;,显然它满足参数定义Pair&lt;? extends Number&gt;,然而，Pair&lt;Double&gt;的setFirst()显然无法接受Integer类型。</p><p>这就是&lt;? extends Number&gt;通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number的子类型给setFirst(? extends Number)。</p><h3 id="extends通配符的作用"><a href="#extends通配符的作用" class="headerlink" title="extends通配符的作用"></a>extends通配符的作用</h3><p>对于Java标准库的java.util.List&lt;T&gt;接口，它实现的是一个类似“可变数组”的列表，只要功能包括：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface List&lt;T&gt;&#123;    int size();    T get(int index);    void add(T t);    void remove(T t);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，让我们定义一个方法来处理列表的每个元素：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int sumOfList(List&lt;? extends Integer&gt; list)&#123;    int sum &#x3D; 0;    for (int i&#x3D;0; i &lt; lise.size();; i++)&#123;        Integer n &#x3D; list.get(i);        sum +&#x3D; n;    &#125;    return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>List&lt;? extends Integer&gt;的作用：</p><ul><li>允许调用get()方法获取Integer的引用；</li><li>不允许调用set(? extends Integer)方法并传入任何Integer的引用。</li></ul><p>因此，方法参数类型List&lt;? extends Integer&gt;表明了该方法内部只会读取List的元素，不会修改List的元素。</p><h3 id="使用extends限定T类型"><a href="#使用extends限定T类型" class="headerlink" title="使用extends限定T类型"></a>使用extends限定T类型</h3><p>在定义泛型类型Pair&lt;T&gt;的时候，也可以使用extends通配符来限定T的类型：</p><p><code>public class Pair&lt;T extends Number&gt;</code></p><p>现在只能定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Pair&lt;Number&gt; p1 &#x3D; null;Pair&lt;Integer&gt; p2 &#x3D; new Pair&lt;&gt;(1, 2);Pair&lt;Double&gt; p3 &#x3D; null;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>使用&lt;? extends Number&gt;通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取Number引用的方法，例如：Number n = obj.getFirst();</li><li>方法内部无法调用传入Number引用的方法，例如obj.setFirst(Number n);</li></ul><p>即使用extends通配符表示可以读，不能写。</p><p>使用类似&lt;T extends Number&gt;定义泛型类时表示：</p><ul><li>泛型类型限定为Number及其子类。</li></ul><h2 id="6-super通配符"><a href="#6-super通配符" class="headerlink" title="6. super通配符"></a>6. super通配符</h2><p>前面已经讲到了泛型的继承关系，Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类。</p><p>考察下面的set方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void set(Pair&lt;Integer&gt; p, Integer first, Integer last)&#123;    p.setFirst(first);    p.setLast(last);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>传入Pair&lt;Integer&gt;是允许的，但是传入Pair&lt;Number&gt;是不允许的。</p><p>和extends通配符相反，这次，我们希望接受Pair&lt;Integer&gt;类型，以及Pair&lt;Number&gt;、Pair&lt;Object&gt;，因为Number和Object是Integer的父类，setFirst(Number)和setFirst(Object)实际上允许接受Integer类型。</p><p>我们使用super通配符来改写这个方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void set(Pair&lt;? super Integer&gt; p, Integer first, Integer last)&#123;    p.setFirst(first);    p.setLast(last);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Pair&lt;? super Integer&gt;表示，方法参数接受所有泛型类型为Integer或其父类的Pair类型。</p><p>使用&lt;? super Integer&gt;通配符表示：</p><ul><li>允许调用set(? super Integer)方法传入Integer的引用；</li><li>不允许调用get()方法获得Integer的引用；</li></ul><p>也就是说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p><p>来看看Java标准库的Collections类定义的copy()方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Collections &#123;    &#x2F;&#x2F; 把src的每个元素复制到dest中：    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)&#123;        for (int i &#x3D; 0; i &lt;src.size(); i++&gt;)&#123;            T t &#x3D; src.get(i);            dest.add(t);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的作用是把一个List的每个元素依次添加到另一个List中。第一个参数是List&lt;? super T&gt;, 第二个参数是List&lt;? extends T&gt;,对于变量src，可以安全地获取类型T的引用，而对于变量dest，可以安全地传入T的引用。</p><p>这个copy()方法可以避免代码中意外修改src，或者意外读取dest。它的另一个好处是可以安全地把一个List&lt;Integer&gt;添加到List&lt;Number&gt;，但是无法反过来添加。</p><h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><p>我们已经讨论了&lt;? extends T&gt;和&lt;? super T&gt;作为方法参数的作用。实际上Java的泛型还允许使用无限定通配符，即只定义一个?:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void sample(Pair&lt;?&gt; p)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于&lt;?&gt;通配符：</p><ul><li>不允许调用set(T)方法并传入引用；</li><li>不允许调用T get()方法并获取T引用。</li></ul><p>换句话说，既不能读，也不能写，只能做一些null判断：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">static boolean isNUll(Pair&lt;?&gt; p)&#123;    return p.getFirst() &#x3D;&#x3D; null || p.getLast() &#x3D;&#x3D; null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&lt;?&gt;通配符还有一个特点，就是Pair&lt;?&gt;是所有Pair&lt;T&gt;的超类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Pair&lt;Integer&gt; p &#x3D; new Pair&lt;&gt;(1, 2);Pair&lt;?&gt; p2 &#x3D; p; &#x2F;&#x2F;安全地向上转型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>使用类似&lt;? super Integer&gt;通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入Integer引用的方法，例如：obj.getFirst(Integer n);</li><li>方法内部无法调用获取Integer引用的方法，例如：Integer n = obj.getFirst();</li></ul><p>无限定通配符&lt;?&gt;很少使用，可以使用&lt;T&gt;替换，同时它是所有&lt;T&gt;类型的超类。</p><h2 id="7-泛型与反射"><a href="#7-泛型与反射" class="headerlink" title="7. 泛型与反射"></a>7. 泛型与反射</h2><p>Java的部分反射API也是泛型。例如：class&lt;T&gt;就是泛型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;compile warningClass clazz &#x3D; String.class;String str &#x3D; (String) clazz.newInsatnce();&#x2F;&#x2F; no waringClass&lt;String&gt; clazz &#x3D; String.class;String str &#x3D; class.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：String.class返回的类型是Class<String>。</p><p>调用Class的getSuperclass()方法返回的Class类型是Class&lt;? super T&gt;。</p><p><code>Class&lt;? super String&gt; sup = String.class.getSuperclass();</code></p><p>构造方法Constructor<T>也是泛型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;Integer&gt; clazz &#x3D; Integer.class;Constructor&lt;Integer&gt; cons &#x3D; class.getConstructor(int.class);Integer i &#x3D; cons.newInstance(123);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以声明带泛型的数组，但不能用new操作符创建带泛型的数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Pair&lt;String&gt;[] ps &#x3D; null;Pair&lt;String&gt;[] ps &#x3D; new Pair&lt;String&gt;[2];    &#x2F;&#x2F;compile error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>必须通过强制转型实现带泛型的数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;)Pair&lt;String&gt;[] ps &#x3D; (Pair&lt;String&gt;[]) new Pair[2];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量ps，因为它的类型是泛型数组。但是编译器不会检查变量arr，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作arr可能导致从ps获取元素时报错，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Pair[] arr &#x3D; new Pair[2];Pair&lt;String&gt;[] ps &#x3D; (Pair&lt;String&gt;[]) arr;ps[0] &#x3D; new Pair&lt;String&gt;(&quot;a&quot;, &quot;b&quot;);arr[1] &#x3D; new Pair&lt;Integer&gt;(1, 2);&#x2F;&#x2F; ClassCastException:Pair&lt;String&gt; p &#x3D; ps[1];String s &#x3D; p.getFirst();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要安全地使用泛型数组，必须扔掉arr的引用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;)Pair&lt;String&gt;[] ps &#x3D; (Pair&lt;String&gt;[]) new Pair[2];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组ps进行操作，这种操作就是安全的。</p><p>带泛型的数组实际上是编译器的类型擦除：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Pair[] arr &#x3D; new Pair[2];Pair&lt;String&gt;[] ps &#x3D; (Pair&lt;String&gt;[]) arr;System.out.println(ps.getClass() &#x3D;&#x3D; Pair[].class);  &#x2F;&#x2F;trueString s1 &#x3D; (String) arr[0].getFirst();String s2 &#x3D; ps[0].getFirst();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以不能直接创建泛型数组T[],因为擦拭后变成Object[]:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; compile error:public class Abc&lt;T&gt;&#123;    T[] createArray()&#123;        return new T[5];    &#125;&#125;&#x2F;&#x2F; 借助Class&lt;T&gt;来创建泛型数组：T[] createArray(Class&lt;T&gt; cls)&#123;    return (T[]) Array.newInstance(cls, 5);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以通过可变参数创建泛型数组T[]:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayHelper&#123;    @SafeVarargs    static &lt;T&gt; T[] asArray(T... objs)&#123;        return objs;    &#125;&#125;String[] ss &#x3D; ArrayHelper.asArray(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Integer[] ns &#x3D; ArrayHelper.asArray(1, 2, 3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>部分反射API是泛型，如：Class&lt;T, Constructor&lt;T&gt;;<br>可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；<br>可以通过Array.newInstance(Class&lt;T&gt;, int)创建T[]数组，需要强制转型；</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="2021/011816112.html"/>
      <url>2021/011816112.html</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h2><h3 id="6-1-1-接口概念"><a href="#6-1-1-接口概念" class="headerlink" title="6.1.1 接口概念"></a>6.1.1 接口概念</h3><p>接口不是类，是对类的一组需求描述。Array类中的sort方法可以对对象数组进行排序，但要求对象所属的类必须实现Comparable接口。<br>下面是Comparable接口的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Comparable&#123;    int compareTo(Object other);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，任何实现Comparable接口的类都需要包含compareTo方法，并且这个方法的参数是一个Object对象，返回一个整形数值。</p><p>接口中的所有方法自动声明为public，因此接口中的方法无需提供关键字public。<br>接口中可以声明多个方法，可以定义常量，但绝对不能含有实例域。提供实例域和方法实现的任务应该由实现接口的类来完成。可以暂时将接口看成没有实例域的抽象类。</p><p>为了让类实现一个接口，包含两个步骤：</p><ul><li>1.将类声明为实现某个接口</li><li>2.对接口中的所有方法进行定义</li></ul><p>使用implements关键字  </p><p><code>class Employee implements Comparable</code></p><p>Employee类中应提供compareTo方法的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee implements Comparable&#123;    public int compareTo(Object otherObject)    &#123;        Employee other &#x3D; (Employee) otherObject;        return Double.compare(salary, other.salary);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为何不在类中直接定义compareTo方法，原因是在编译时会检查对象是否实现了某个方法。只要Employee是一个Comparable的，其就一定实现了compareTo方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">部分APIjava.lang.Comparable&lt;T&gt;int compareTo(T other)java.util.Arraysstatic void sort(Object[] a)java.lang.Integerstatic int compare(int x, int y)java.lang.Doublestatic int compare(double x, double y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-2-接口的特性"><a href="#6-1-2-接口的特性" class="headerlink" title="6.1.2 接口的特性"></a>6.1.2 接口的特性</h3><p>接口不是类，不能用new运算符实例化一个接口。</p><p>不能构造接口的对象，但可以声明一个接口的变量。<br><code>Comparable x;</code></p><p>接口变量必须引用实现了接口的类对象：</p><p><code>x = new Employee(...);</code></p><p>使用instanceof检查一个对象是否实现了某个特定的接口。<br><code>if (anObject instanceof Comparable) &#123;...&#125;</code></p><p>与可以建立类的继承关系一样，接口也可以被扩展。假设有一个Moveable的接口：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Moveable&#123;    void move(double x, double y);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以它为基础扩展一个Powered的接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Powered extends Moveable&#123;    double milesPerGallon();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>虽然接口中不能包含实例域或静态方法，但却可以包含常量。例如：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Powered extends Moveable&#123;    double milesPerGallon();    double SPEED_LIMIT &#x3D; 95;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口中的域被自动设定为public static final。</p><h3 id="6-1-3-接口与抽象类"><a href="#6-1-3-接口与抽象类" class="headerlink" title="6.1.3 接口与抽象类"></a>6.1.3 接口与抽象类</h3><p>为何不适用抽象类实现上文的Comparable方法呢，因为java支持单继承，每个类只能扩展一个类，假设Employee继承了Person，就不能再扩展第二个类了，但是却可以实现多个接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee extends Person, Comparable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-1-4-静态方法"><a href="#6-1-4-静态方法" class="headerlink" title="6.1.4 静态方法"></a>6.1.4 静态方法</h3><p>从Java SE8开始，允许在接口中添加静态方法，但通常做法是<br>将静态方法放在伴随类中。在标准库中，有成对出现的接口和实用工具类，如Collection/Collections或Path/Paths。</p><p>在Paths类中，只包含两个工厂方法。由一个字符序列构造一个文件或目录的路劲，如Path.get(“jdk1.8.0”, “jre”, “bin”)。在Java SE8中，可以为Path接口添加以下方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Path&#123;    public static Path get(String first, String... more)&#123;        return FileSystems.getDefault().getPath(first, more);    &#125;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，Paths类就不是必要的了。在实现你自己的接口时，不再需要为实用工具方法另外提供一个伴随类。</p><h3 id="6-1-5-默认方法"><a href="#6-1-5-默认方法" class="headerlink" title="6.1.5 默认方法"></a>6.1.5 默认方法</h3><p>可以为接口提供一个默认实现。必须用default修饰符标记这样一个方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">piblic interface Comparable&lt;T&gt;&#123;    default int compareTo(T other)&#123;return 0;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>默认方法的应用：</p><p>如希望在发生鼠标点击事件的时得到通知，就要实现一个包含5个方法的接口，在大多数情况下，只需要关心其中的1、2个事件类型。在Java SE8中，可以把所有方法声明为默认方法，这些默认方法什么也不做。实现这个接口时只需要覆盖那些自己关系的方法就行了。默认方法可以调用任何其他方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface MouseListener&#123;    default void mouseClicked(MouseEvent event)&#123;&#125;    default void mousePressed(MouseEvent event)&#123;&#125;    default void mouseReleased(MouseEvent event)&#123;&#125;    default void mouseEntered(MouseEvent event)&#123;&#125;    default void mouseExited(MouseEvent event)&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-6-解决默认方法冲突"><a href="#6-1-6-解决默认方法冲突" class="headerlink" title="6.1.6 解决默认方法冲突"></a>6.1.6 解决默认方法冲突</h3><p>如果在一个接口中定义了一个默认方法，然后又在超类或另一个接口中定义了同样的方法，规则如下：</p><ol><li>超类优先，此时同名同参数的默认方法被忽略。</li><li>接口冲突，如果一个超接口提供了一个默认方法，另一个接口提供了同名同参数类型的方法，则必须覆盖这个方法解决冲突。</li></ol><p>考虑一个包含getName方法的接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Named&#123;    default String getName()&#123;        return getClass.getName() + &quot;_&quot; + hashCode();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个类同时实现了这两个接口：<br><code>class Student implements Person, Named&#123;...&#125;</code></p><p>Java编译器将报错，让程序员解决这个二义性。选择两个冲突方法中的一个。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Student implements Person, Named&#123;    public String getName()&#123;return Person.super.getName();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是第一种情况，如<code>class Student extends Person implements Named&#123;...&#125;</code></p><p>这种情况下只会考虑超类方法。</p><h2 id="6-2-接口示例"><a href="#6-2-接口示例" class="headerlink" title="6.2 接口示例"></a>6.2 接口示例</h2><p>接口的另外一些使用场景</p><h3 id="6-2-1-接口与回调"><a href="#6-2-1-接口与回调" class="headerlink" title="6.2.1 接口与回调"></a>6.2.1 接口与回调</h3><p>回调是一种常见的设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p><p>Java.swing包有一个Timer类，可以使用它在到达指定时间间隔发出通告。在构造定时器时，需要设置一个一个时间间隔，并告知定时器，当达到时间间隔时需要做哪些操作。</p><p>在Java类库中采用的是面向对象方法。它将某个类的对象传递给定时器，然后定时器调用这个对象的方法。</p><p>定时器需要知道调用哪一个方法，并要求传递的对象所属的类实现了java.awt.event包的ActionListener接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ActionListener&#123;    void actionPerformed(ActionEvent event);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当到达指定的时间，定时器就调用actionPerformed方法。</p><p>如希望每隔10s打印一条信息”At the tone, the time is …”，就应该定义一个实现ActionListener接口的类，然后将需要执行的语句放在actionPerformed方法中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TimePrinter implements ActionListener&#123;    public void actionPerformed(ActionEvent event)    &#123;        System.out.println(&quot;At the tone, the time is &quot; + new Date());    &#125;&#125;ActionListener listener &#x3D; new TimePrinter();Timer t &#x3D; new Timer(10000, listener);t.start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-2-Comparator接口"><a href="#6-2-2-Comparator接口" class="headerlink" title="6.2.2 Comparator接口"></a>6.2.2 Comparator接口</h3><p>Array.sort方法还有第二个版本，有一个数组和一个比较器（comparator）作为参数，比较器是实现了Comparator接口的类的实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Comparator&lt;T&gt;&#123;    int compare(T first, T second);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>要按长度比较字符串，可以定义一个实现Comparator<String>的类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class LengthComparator implements Comparator&lt;String&gt;&#123;    public int compare(String first, String second)&#123;        return first.length() - second.length();    &#125;&#125;&#x2F;&#x2F;对一个数组排序， 需要为Arrays.sort方法传入一个LengthComparator对象String[] firends &#x3D; &#123;&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;&#125;;Array.sort(firends, new LengthComparator());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-3-对象克隆"><a href="#6-2-3-对象克隆" class="headerlink" title="6.2.3 对象克隆"></a>6.2.3 对象克隆</h3><p>本节讨论Cloneable接口，这个接口指示一个类提供了一个安全的clone方法。</p><p>对于一个对象引用的变量创建副本时，它们都是引用的同一个对象，改变一个变量会影响另一个变量。如果希望copy是一个新对象，初始状态一致，但之后它们有各自的状态，这种情况下应该使用clone方法。<br>如果对象中数据域仍然含有对其他对象的引用，那么拷贝得到的是相同子对象的引用，即浅拷贝。</p><p>通常必须子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象。这样类必须<strong>实现Cloneable接口</strong>，并<strong>重新定义clone方法</strong>，指定public访问修饰符。（clone方法在Object类中声明为protected，子类只能调用受保护的clone方法来克隆它自己的对象。必须重新定义clone为public才能允许所有方法克隆对象）</p><p>Employee类深拷贝的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee implements Cloneable&#123;    public Employee clone() throws CloneNotSupportedException    &#123;        &#x2F;&#x2F;call Object.clone        Employee cloned &#x3D; (Employee) super.clone();        &#x2F;&#x2F;clone mutable fields        cloned.hireDay &#x3D; (Date) hireDay.clone();        return cloned;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-3-lambda表达式"><a href="#6-3-lambda表达式" class="headerlink" title="6.3 lambda表达式"></a>6.3 lambda表达式</h2><p>本节学习如何使用lambda表达式采用一种简洁的语法定义代码块，以及如何编写处理lambda表达式的代码。</p><h3 id="6-3-1-lambda表达式的语法"><a href="#6-3-1-lambda表达式的语法" class="headerlink" title="6.3.1 lambda表达式的语法"></a>6.3.1 lambda表达式的语法</h3><p>第一个示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">(String first, String second)     -&gt; first.length() - second.length()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二个示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">(String first, String second) -&gt;    &#123;        if(first.length() &lt; second.length()) return -1;        else if (first.length() &gt; second.length()) return 1;        else return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使lambda表达式没有参数，也要提供空括号：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">() -&gt; &#123;for (int i&#x3D;100; i&gt;&#x3D;0; i--) System.out.println(i);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-3-2-函数式接口"><a href="#6-3-2-函数式接口" class="headerlink" title="6.3.2 函数式接口"></a>6.3.2 函数式接口</h3><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口。</p><p>考虑Arrays.sort方法，它的第二个参数需要一个Comparator实例，Comparator就是只有一个方法的接口，可以提供一个lambda表达式:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Arrays.sort(words,    (first, second) -&gt; first.length() - second.length());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-3-3-方法引用"><a href="#6-3-3-方法引用" class="headerlink" title="6.3.3 方法引用"></a>6.3.3 方法引用</h3><p>假设希望定时器在出现一个定时器事件时就打印这个事件对象，可以调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Timer t &#x3D; new Timer(1000, event -&gt; System.out.println(event));&#x2F;&#x2F;直接把println方法传递给Timer构造器就更好了Timer t &#x3D; new Timer(1000, System.out::println);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表达式System.out::println是一个方法引用，它等价于lambda表达式x-&gt;System.out.println(x)。</p><p>使用::操作符分隔方法名与对象名或类名，只要有3种情况：<br>object::instanceMethod<br>Class::staticMethod<br>Class::instanceMethod<br>前两种情况下，方法引用等价于提供方法参数的lambda表达式。System.out::println等价于x-&gt;System.out.println(x)。类似地，Math.pow等价于(x, y) -&gt; Math.pow(x, y)。</p><p>对于第三种情况，第一个参数会称为方法的目标。例如：String::compareToIgnoreCase等同于(x, y) -&gt; x.compareToIgnoreCase(y)。<br>还可以在方法引用中使用this, super参数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Greeter&#123;    public void greet()    &#123;        System.out.println(&quot;Hello World&quot;);    &#125;&#125;class TimedGreeter extends Greeter&#123;    public void greet()    &#123;        Timer t &#x3D; new Timer(1000, super::great);        t.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TimedGreeter.greet方法开始执行时，会构造一个Timer，它每次定时执行super::great方法。这个方法调用超类的greet方法。</p><h3 id="6-3-4-构造器引用"><a href="#6-3-4-构造器引用" class="headerlink" title="6.3.4 构造器引用"></a>6.3.4 构造器引用</h3><p>构造器引用与方法引用类似，只不过方法名为new。例如Person::new是Person构造器的一个引用。哪一个构造器呢？这取决于上下文。假设你有一个字符串列表，可以把它转换为一个Person对象数组，为此要在各个字符串上调用构造器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList&lt;String&gt; names &#x3D; ...;Stream&lt;Person&gt; stream &#x3D; names.stream().map(Person::new);List&lt;Person&gt; people &#x3D; stream.collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>map方法为每一个列表元素调用Person(String)构造器。</p><p>可以用数组类型建立构造器引用。例如：int[]::new是一个构造器引用，它有一个参数：即数组的长度。这等价于lambda表达式x-&gt;new int[x]。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person[] people &#x3D; stream.toArray(Person[]::new);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>toArray方法调用这个构造器来得到一个正确类型的数组，然后填充这个数组并返回。</p><h3 id="6-3-5-变量作用域"><a href="#6-3-5-变量作用域" class="headerlink" title="6.3.5 变量作用域"></a>6.3.5 变量作用域</h3><p>通常，你可能希望能够在lambda表达式中访问外围方法或类中的变量。考虑下面的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void repeatMessage(String text, int delay)&#123;    ActionListener listener &#x3D; event -&gt;    &#123;        System.out.println(text);        Toolkit.getDefaultToolkit().beep();    &#125;;    new Timer(delay, listener).start();&#125;repeatMessage(&quot;Hello&quot;, 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lambda表达式中的变量text是一个repeatMessage中定义的变量。lambda表达式可以捕获外围作用域中变量的值，这里有一个重要的限制：在lambda表达式中，只能引用值不会改变的变量。因为如果在lambda表达式中改变变量，并发地执行多个动作时就会不安全。如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的。</p><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application()&#123;    public void init()&#123;        ActionListener listener &#x3D; event -&gt;        &#123;            System.out.println(this.toString());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达式this.toString()会调用Application对象的toString方法，而不是ActionListener实例的方法。lambda表达式的作用域嵌套在init方法中，与出现在这个方法中的其他位置一样，lambda表达式的this含义并没有改变。</p><h2 id="6-4-内部类"><a href="#6-4-内部类" class="headerlink" title="6.4 内部类"></a>6.4 内部类</h2><p>内部类是定义在另一个类中的类。使用内部类的几点原因：</p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li><li>内部类可以对同一个包中其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较方便</li></ul><h3 id="6-4-1-使用内部类访问对象状态"><a href="#6-4-1-使用内部类访问对象状态" class="headerlink" title="6.4.1 使用内部类访问对象状态"></a>6.4.1 使用内部类访问对象状态</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TalkingColock&#123;    private int interval;    private boolean beep;    public TalkingClock(int interval, boolean beep)&#123;...&#125;    public void start()&#123;...&#125;    public class TimePrinter implements ActionListener    &#123;        public void actionPerformed(ActionEvent event)        &#123;            System.out.println(&quot;At the tone, the time is &quot;+new Date());            if(beep) Toolkit.getDefaultToolkit().beep();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TimePrinter类没有实例域或名为beep的变量，beep引用了创建TimePrinter的TalkingClock对象的域。内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。内部类的对象总是有一个隐式引用，它指向了创建它的外部类对象。</p><h3 id="6-4-2-内部类的特殊语法规则"><a href="#6-4-2-内部类的特殊语法规则" class="headerlink" title="6.4.2 内部类的特殊语法规则"></a>6.4.2 内部类的特殊语法规则</h3><p>内部类有一个外围类的引用outer。使用外围类的正规语法为：<code>outerClass.this</code>。<br>可以这样编写TimePrinter内部类的actionPerformed方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void actionPerformed(ActionEvent event)&#123;    ...    if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以这样编写内部对象的构造器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; outerObject.new InnerClass(construction parameters)ActionListener listener &#x3D; this.new TimePrinter();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-4-3-静态内部类"><a href="#6-4-3-静态内部类" class="headerlink" title="6.4.3 静态内部类"></a>6.4.3 静态内部类</h3><p>如果使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象，可以将内部类声明为<strong>static</strong>,以便取消产生的引用.</p><p>计算数组中的最大值和最小值的问题:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">double min &#x3D; Double.POSITIVE_INFINITY;double max &#x3D; Double.NEGATIVE_INFINITY;for(double v : values)&#123;    if(min &gt; v) min &#x3D; v;    if(max &lt; v) max &#x3D; v;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法必须返回两个数值,为此可以定义一个包含两个值的类Pair:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Pair&#123;    private double first;    private double second;    public Pair(double f, double s)    &#123;        first &#x3D; f;        second &#x3D; s;    &#125;    public double getFirst() &#123;return first;&#125;    public double getSecond() &#123;return second&#125;;&#125;class ArrayAlg&#123;    public static Pair minmax(double[] values)    &#123;        ...        return new Pair(min, max);    &#125;&#125;Pair p &#x3D; ArrayAlg.minmax(d);System.out.println(p.getFirst());System.out.println(p&#x2F;getSecond());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将Pair定义为ArrayAlg的内部公有类,通过ArrayAlg.Pair访问它:</p><p><code>ArrayAlg.Pair p = ArrayAlg.minmax(d);</code></p><p>与前面的内部类不同,在Pair对象中不需要引用任何其他的对象,可以将这个内部类声明为static:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ArrayAlg&#123;    public static class Pair    &#123;        ...    &#125;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整的程序:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticInnerClass;public class StaticInnerClassTest&#123;    public static void main(String[] args)    &#123;        double[] d &#x3D; new double[20];        for( int i&#x3D;0; i &lt; d.length; i++)            d[i] &#x3D; 100 * Math.random();        ArrayAlg.Pair p &#x3D; ArrayAlg.minmax(d);        System.out.println(&quot;min &#x3D; &quot; + p.getFirst());        System.out.println(&quot;max &#x3D; &quot; + p.getSecond());    &#125;&#125;class ArrayAlg&#123;    public static class pair    &#123;        private double first;        private double second;                public Pair(double f, double s)        &#123;            first &#x3D; f;            second &#x3D; s;        &#125;         public double getFirst()        &#123;            return first;        &#125;        public double getSecond()        &#123;            return second;        &#125;    &#125;    public static Pair minmax(double[] values)    &#123;        double min &#x3D; Double.POSITIVE_INFINITY;        double max &#x3D; Double.NEGATIVE_INFINITY;        for (double v : values)        &#123;            if(min &gt; v) min &#x3D; v;            if(max &lt; v) max &#x3D; v;        &#125;        return new Pair(min, max);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-代理"><a href="#6-5-代理" class="headerlink" title="6.5 代理"></a>6.5 代理</h2><p>利用代理可以在运行时创建一个实现了一组给定接口的新类.</p><h3 id="6-5-1-何时使用代理"><a href="#6-5-1-何时使用代理" class="headerlink" title="6.5.1 何时使用代理"></a>6.5.1 何时使用代理</h3><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</p><p>代理类可以在运行时创建全新的类,这样的代理类能够实现指定的接口,它具有下列方法：</p><ul><li>指定接口所需要的全部方法。</li><li>Object类中的全部方法，例如，toString、equals等。</li></ul><p>不能在运行时定义这些方法的新代码，而是要提供一个调用处理器(invocation handler)。调用处理器是实现了InvocationHandler接口的类对象.在这个接口中只有一个方法:</p><p>Object invoke(Object proxy, Method method, Object[] args)</p><p>无论何时调用代理对象的方法,调用处理器的invoke方法都会被调用,并向其传递Method对象和原始的调用参数.调用处理器需要给出处理调用的方式.</p><h3 id="6-5-2-创建代理对象"><a href="#6-5-2-创建代理对象" class="headerlink" title="6.5.2 创建代理对象"></a>6.5.2 创建代理对象</h3><p>要创建一个代理对象，使用Proxy类的newProxyInstance方法,该方法有三个参数:</p><ul><li>类加载器(class loader),可以使用不同的类加载器,目前用null表示默认的类加载器.</li><li>一个Class对象数组,每个元素都是需要实现的接口.</li><li>一个调用处理器.</li></ul><p>示例程序中，使用代理和调用处理器跟踪方法调用，并且定义了一个TraceHandler包装器存储包装对象。其中的invoke方法打印出被调用方法的名字和参数，随后用包装好的对象作为隐式参数调用这个方法。<br>示例:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TraceHandler implements InvocationHandler&#123;    private Object target;    public TraceHandler(Object t)    &#123;        target &#x3D; t;    &#125;    public Object invoke(Object proxy, Method m, Object[] args) throws Throwable    &#123;        &#x2F;&#x2F;print method name and parameters        ...        &#x2F;&#x2F;invoke actual method        return m.invoke(target, args);    &#125;&#125;&#x2F;&#x2F;构造用于跟踪方法调用的代理对象Object value &#x3D; ...;InvocationHandler handler &#x3D; new TraceHandler(value);Class[] interfaces &#x3D; new Class[] &#123;Comparable.class&#125;;Object proxy &#x3D; Proxy.newProxyInstance(null, interfaces, handler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论何时使用proxy调用某个方法，这个方法的名字和参数就会打印出来，之后再用value调用它。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020房价排行榜</title>
      <link href="2021/011016111.html"/>
      <url>2021/011016111.html</url>
      
        <content type="html"><![CDATA[<h1 id="2020年各市房价涨跌情况"><a href="#2020年各市房价涨跌情况" class="headerlink" title="2020年各市房价涨跌情况"></a>2020年各市房价涨跌情况</h1><div style = "position:relative; width: 100%; height:0; padding-bottom:75%;"><iframe src="//player.bilibili.com/player.html?aid=798567192&bvid=BV1Sy4y127GX&cid=280560426&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"style="position:absolute; width:100%; height:100%; left: 0; top: 0;"> </iframe></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java类的继承</title>
      <link href="2020/122316110.html"/>
      <url>2020/122316110.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="5-1类、超类、子类"><a href="#5-1类、超类、子类" class="headerlink" title="5.1类、超类、子类"></a>5.1类、超类、子类</h2><p>Employee类和Manager类，is-a的关系，Employee类称为超类（父类），Manager类称为子类。</p><h3 id="5-1-1-定义子类"><a href="#5-1-1-定义子类" class="headerlink" title="5.1.1 定义子类"></a>5.1.1 定义子类</h3><p>如何定义Manager类呢？<br><strong>关键字extends表示继承</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Manager extends Employee&#123;    添加方法和域&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Manager添加的域bonus,添加一个setBonus方法。  </li><li>Manager类自动继承了Employee类中的方法，还继承了name, salary, hireDay这些域。</li></ul><h3 id="5-1-2-覆盖方法"><a href="#5-1-2-覆盖方法" class="headerlink" title="5.1.2 覆盖方法"></a>5.1.2 覆盖方法</h3><p>父类Employee的getSalary方法对于子类Manager并不适用，定义一个新的方法来覆盖(override)超类中的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public double getSalary()&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如何实现？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public double getSalary() &#123;    return bonus + super.getSalary();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>super.getSalary()</code>语句调用的是Employee类的getSalary方法。<br>子类可以增加域、方法和覆盖超类的方法，但不能删除继承的任何域或方法。<br>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。如果超类方法是public，那么子类方法一定要声明为public。</p><h3 id="5-1-3-子类构造器"><a href="#5-1-3-子类构造器" class="headerlink" title="5.1.3 子类构造器"></a>5.1.3 子类构造器</h3><p>提供一个Manager类的构造器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Manager(String name, double salary, int year, int month, int day) &#123;    super(name, salary, year, month, day);    bonus &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>super(...)</code>是调用超类Employee的构造器。</p><p>Manager类的构造器不能访问Employee类的私有域，必须利用Employee类的构造器对这部分私有域进行初始化，通过super实现对超类构造器的调用。<br><strong>使用super调用构造器的语句必须是子类构造器的第一条语句</strong></p><p><strong>子类没有显示调用超类的构造器，将自动调用超类默认(没有参数)构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显示调用父类构造器，则java编译器将报错。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager boss &#x3D; new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15);boss.setBonus(5000);Employee[] staff &#x3D; new Employee[3];staff[0] &#x3D; boss;staff[1] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);staff[2] &#x3D; new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15);&#x2F;&#x2F;输出每个人的薪水for (Employee e:staff)&#123;    System.out.println(e.getName() + &quot; &quot; + e.getSalary());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>e.getSalary()</code>调用能够确定执行哪个getSalary方法，虽然e声明为Employee类型，但实际上e既可以引用Employee对象，也可以引用Manager类型对象。</p><p><strong>一个对象变量可以指示多个实际类型的现象称为多态。在运行时能够自动地选择调用哪个方法的现象称为动态绑定。</strong></p><h3 id="5-1-4-继承层次"><a href="#5-1-4-继承层次" class="headerlink" title="5.1.4 继承层次"></a>5.1.4 继承层次</h3><p>继承并不限于一个层次，如还可以由Manager类派生出Executive类。一个祖先类可以拥有多个子孙继承链。例如，可以由Employee类派生出子类Programmer或Secretary，它们与Manager类没有任何关系。</p><h3 id="5-1-5-多态"><a href="#5-1-5-多态" class="headerlink" title="5.1.5 多态"></a>5.1.5 多态</h3><p>任何一个Manager对象也是父类Employee类的对象。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee e;e &#x3D; new Employee(...);e &#x3D; new Manager(...);   &#x2F;&#x2F;ok, Manager can be used as well<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager boss &#x3D; new Manager(...);Employee[] staff &#x3D; new Employee[3];staff[0] &#x3D; boss;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>staff[0]和boss引用同一个对象，但staff[0]被看作Employee对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">boss.setBonus();    &#x2F;&#x2F;Okstaff[0].setBonus(5000);    &#x2F;&#x2F;Error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此外，不能将一个父类的引用赋给一个子类的变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager m &#x3D; staff[i];   &#x2F;&#x2F;Error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-1-6-final类和方法"><a href="#5-1-6-final类和方法" class="headerlink" title="5.1.6 final类和方法"></a>5.1.6 final类和方法</h3><p>不允许扩展的类称为final类。假设希望阻止人们定义Executive类的子类，那么可以在定义时使用final修饰符。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class Executive extends Manager&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类中的特定方法也可以被声明为final，子类不能覆盖这个方法。(final类中的所有方法自动称为final方法, 不包括域)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee&#123;    ...    public final String getName()    &#123;        return name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Calendar类中的getTime和setTime方法都声明为final，String类也是final类。</p><h3 id="5-1-7-强制类型转换"><a href="#5-1-7-强制类型转换" class="headerlink" title="5.1.7 强制类型转换"></a>5.1.7 强制类型转换</h3><p>有时候，需要将某个类的对象引用转换为另外一个类的对象引用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager boss &#x3D; (Manager) staff[0];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将一个子类的引用赋给一个超类变量，编译器是允许的，但将一个超类的引用赋给一个子类变量，必须进行类型转换。</p><h3 id="5-1-8-抽象类"><a href="#5-1-8-抽象类" class="headerlink" title="5.1.8 抽象类"></a>5.1.8 抽象类</h3><p>将Employee类的getName方法放在更高层次通用超类Person中。<br>添加一个getDescription方法，返回对一个人的简短描述。</p><blockquote><p>an employee with a salary of $50000</p><p>a student majoring in computer science</p></blockquote><p>Person类不需要具体去实现getDescription方法，只需提供一个接口，在Person类的方法前加一个abstact关键字。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract String getDescription();    &#x2F;&#x2F;no implementation required<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>包含一个或多个抽象方法的类本身必须被声明为抽象的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Person&#123;    ...    public abstract String getDescription();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了抽象方法，抽象类还可以包含具体数据和具体方法，Person类保存了姓名和一个返回姓名的具体方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Person&#123;    private String name;    public Person(String name)    &#123;        this.name &#x3D; name;    &#125;    public abstract String getDescription();    public String getName()    &#123;        return name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>抽象方法充当占位的角色，具体实现在子类中，通过扩展抽象Person类，并实现getDescription方法来定义Student类。由于在Student类中不含有抽象方法，所以不必将这个类声明为抽象的。(类即使不含有抽象方法，也可以被声明为抽象类)<br>__抽象类不能被实例化__。<br><strong>可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</strong><br>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person[] people &#x3D; new Person[2];people[0] &#x3D; new Employee(...);people[1] &#x3D; new Student(...);for(Person p : people)&#123;    p.getDescription();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上部分源代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Test\package test;public class Test&#123;public static void main(String[] args) &#123;Manager boss &#x3D; new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15);boss.setBonus(5000);Employee[] staff &#x3D; new Employee[3];staff[0] &#x3D; boss;staff[1] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);staff[2] &#x3D; new Employee(&quot;Tommy Tester&quot;, 40000, 1990, 3, 15);for(Employee e:staff) &#123;System.out.println(&quot;name&#x3D;&quot; + e.getName() + &quot;,salary&#x3D;&quot; + e.getSalary());&#125;Person[] people &#x3D; new Person[2];people[0] &#x3D; new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);people[1] &#x3D; new Student(&quot;Maria Morris&quot;, &quot;computer science&quot;);for (Person p : people) &#123;System.out.println(p.getName() + &quot;, &quot; + p.getDescription());&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person\package test;public abstract class Person &#123;private String name;public Person(String name) &#123;this.name &#x3D; name;&#125;public abstract String getDescription();public String getName() &#123;return name;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Student\package test;public class Student extends Person&#123;private String major;public Student(String name, String major) &#123;super(name);this.major &#x3D; major;&#125;public String getDescription() &#123;return &quot;a student majoring in &quot; + major;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee\package test;import java.time.*;public class Employee extends Person&#123;&#x2F;&#x2F;private String name;private double salary;private LocalDate hireDay;public Employee(String name, double salary, int year, int month, int day) &#123;super(name);&#x2F;&#x2F;this.name &#x3D; name;this.salary &#x3D; salary;this.hireDay &#x3D; LocalDate.of(year, month, day);&#125;public String getDescription() &#123;return String.format(&quot;an employee with a salary of $%.2f&quot;, salary);&#125;&#x2F;&#x2F;public String getName() &#123;&#x2F;&#x2F;return name;&#x2F;&#x2F;&#125;public double getSalary() &#123;return salary;&#125;public LocalDate getHireDay() &#123;return hireDay;&#125;public void raiseSalary(double byPercent) &#123;double raise &#x3D; salary * byPercent &#x2F; 100;salary +&#x3D; raise;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Manager\package test;public class Manager extends Employee&#123;private double bonus;public Manager(String name, double salary, int year, int month, int day) &#123;super(name, salary, year, month, day);bonus &#x3D; 0;&#125;public double getSalary() &#123;return bonus + super.getSalary();&#125;public void setBonus(double b) &#123;bonus &#x3D; b;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-9-受保护访问"><a href="#5-1-9-受保护访问" class="headerlink" title="5.1.9 受保护访问"></a>5.1.9 受保护访问</h3><p>最好将类中的域标记为*<strong>private**<em>,方法标记为</em></strong>public***,任何声明为private的内容对其他类都是不可见的，子类也不能访问超类的私有域。<br>有些时候，希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为protected。例如，Employee类中的hireDay如果声明为protected，Manager类中的方法就可以直接地访问它。<br>受保护的方法更具有实际意义，如果需要限制某个方法的使用，就可以将它声明为protected。这表明子类得到信任，可以正确使用这个方法，而其他类则不行。<br>Java用于控制可见性的4个访问修饰符：</p><ul><li>仅对本类可见————private</li><li>对所有类可见————public</li><li>对本包和所有子类可见————protected</li><li>对本包可见————默认，不需要修饰符</li></ul><h2 id="5-2-Object：所有类的超类"><a href="#5-2-Object：所有类的超类" class="headerlink" title="5.2 Object：所有类的超类"></a>5.2 Object：所有类的超类</h2><p>Object类是Java中所有类的始祖。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object obj &#x3D; new Employee(...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面介绍Object类中的一些基本类容：</p><h3 id="5-2-1-equals方法"><a href="#5-2-1-equals方法" class="headerlink" title="5.2.1 equals方法"></a>5.2.1 equals方法</h3><p>检测一个对象是否等于另一个对象<br>equals方法的实现机制</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee&#123;    ...    public boolean equals(Object otherObject)    &#123;        if (this &#x3D;&#x3D; otherObject) return true;        if (otherObject &#x3D;&#x3D; null) return false;        if (getClass() !&#x3D; otherObject.getClass()) return false;        return Objects.equals(name, other.name) &amp;&amp; salary &#x3D;&#x3D; other.salary &amp;&amp; Object.equals(hireDay, other.hireDay);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果父类中的域都相等，就需要比较子类中的域。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Manager extends Employee&#123;    ...    public boolean equals(Object otherObject)    &#123;        if (!super.equals(otherObject)) return false;        Manager other &#x3D; (Manager) otherObject;        return bonus &#x3D; other.bonus;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-2-toString方法"><a href="#5-2-2-toString方法" class="headerlink" title="5.2.2 toString方法"></a>5.2.2 toString方法</h3><p>返回表示对象值的字符串<br>Employee类的toString方法的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String toString() &#123;    return getClass().getName()    + &quot;[name&#x3D;&quot; + name    + &quot;,salary&#x3D;&quot; + salary    + &quot;,hireDay&#x3D;&quot; + hireDay    + &quot;]&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Manager类的toString方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Manager extends Employee&#123;    ...    public String toString()    &#123;        return super.toString()          + &quot;[bonus&#x3D;&quot; + bonus          + &quot;]&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h2><p>ArrayList是一个采用类型参数的泛型类，用一对尖括号将类名括起来加在后面，例如ArrayList&lt;Employee&gt;。ArrayList在添加或删除元素时，可以自动调节数组容量。<br>声明一个保存Employee对象的数组列表<br><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</code><br>可以省略右边的类型参数：<br><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;();</code></p><p>使用add方法将元素添加到数组列表中</p><p><code>staff.add(new Employee(&quot;Harry Hacker&quot;, ...));</code></p><p>使用<code>staff.ensureCapacity(100)</code>将分配一个包含100个对象的内部数组，这样在调用100次add，不会重新分配空间。<br>或者，可以把初始容量传递给ArrayList构造器：<br><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100);</code></p><p><code>staff.size()</code>返回数组列表的当前元素数量，等价于数组的a.length功能<br>在确认不会添加新元素时，可以使用trimToSize方法将数组列表的容量调整为当前元素数量所需的存储空间数目。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">部分APIArrayList&lt;E&gt;()构造一个空数组列表ArrayList&lt;E&gt;(int initialCapacity)用指定容量构造一个空数组列表boolean add(E obj)在数组列表的尾端添加一个元素，永远返回trueint size()返回存储在数组列表中元素的数量void ensureCapacity(int capacity)确保数组列表在不重新分配存储空间的情况下能够保存给定数量的元素void trimToSize()将数组列表的存储容量削减至当前尺寸<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-1-访问数组列表元素"><a href="#5-3-1-访问数组列表元素" class="headerlink" title="5.3.1 访问数组列表元素"></a>5.3.1 访问数组列表元素</h3><p>使用get和set方法实现访问和改变数组元素的操作。</p><p><code>staff.set(i, harry);</code></p><p>等价于数组中的a[i] = harry;</p><p>获取数组列表中的元素：</p><p><code>Employee e = staff.get(i);</code></p><p>在某个位置插入或删除元素：</p><p><code>int n = staff.size() / 2; staff.add(n, e); Employee e = staff.remove(n); </code></p><p>数组列表的内容拷贝至数组：toArray方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList&lt;X&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(X);...X[] a &#x3D; new X[list.size()];list.toArray(a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“for each”循环遍历数组列表 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (Employee e:staff)&#123;do something with e;&#125;for (int i&#x3D;0; i &lt; staff.size(); i++)&#123;Employee e &#x3D; staff.get(i);do something with e;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">APIvoid set(int index, E obj)改变指定位置的值参数：index位置(0~size()-1)obj:新的值E get(int index)获得指定位置的元素值void add(int index, E obj)E remove(int index)删除一个元素，返回被删除的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-对象包装器与自动装箱"><a href="#5-4-对象包装器与自动装箱" class="headerlink" title="5.4 对象包装器与自动装箱"></a>5.4 对象包装器与自动装箱</h2><p>假如要将int这样的基本类型转换为对象，所有的基本类型都有一个与之对应的类。Integer类对应的基本类型是int，这种类称为包装器，如：Integer、Long、Float、Double、Short、Byte、Character、Void、Boolean。<br>对象包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，对象包装器类还是final，不能定义它们的子类。</p><p>定义一个整形数组列表：<br><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code>  </p><p><code>list.add(3)</code>将自动变为<code>list.add(Integer.valueOf(3))</code>,这种变换称为自动装箱。</p><p><code>int n = list.get(i)</code>相当于<code>int n = list.get(i).intValue();</code>这种变换为自动拆箱。</p><h2 id="5-5-参数数量可变的方法"><a href="#5-5-参数数量可变的方法" class="headerlink" title="5.5 参数数量可变的方法"></a>5.5 参数数量可变的方法</h2><p>printf就是一个参数数量可变的方法，其定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PrintStream&#123;public PrintStream printf(String fmt, Object... args);&#123;return format(fmt, args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Object…表明这个方法可以接受任意数量的对象,相当于Object[]数组。</p><p><code>System.out.printf(&quot;%d %s&quot;, new Object[] &#123;new Integer(n), &quot;widgets&quot;&#125;);</code></p><p>自定义可变参数数量的方法：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static double max(double... values)&#123;double largest &#x3D; Double.NEGATIVE_INFINITY;for (double v: values) if(v &gt; largest) largest &#x3D; v;return largest;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在调用double m = max(3.1, 40.4, -5)时编译器将<br>new double[] {3.1, 40.4, -5}传递给max方法。</p><h2 id="5-6-反射"><a href="#5-6-反射" class="headerlink" title="5.6 反射"></a>5.6 反射</h2><p>反射机制可以用来：</p><ul><li>在运行时分析类的能力</li><li>在运行时查看对象</li><li>实现通用的数组操作代码</li><li>利用Method对象</li></ul><h3 id="5-6-1-Class类"><a href="#5-6-1-Class类" class="headerlink" title="5.6.1 Class类"></a>5.6.1 Class类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee e;...Class c1 &#x3D; e.getClass();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Object类中的getClass()方法将返回一个Class类型的实例，一个Class对象将表示一个特定类的属性。最常用的Class方法是getName，这个方法返回类的名字。</p><p>e.getClass().getName()</p><p>如果e是一个雇员，将返回Employee，如果e是一个经理，将返回Manager。<br>类在一个包里，包的名字也作为类名的一部分。  </p><p>还可以调用Class类的静态方法forName获得类名对应的Class对象。<br>String className = “java.util.Random”;<br>Class c1 = Class.forName(classname);</p><p>获取Class类对象的第三种方法是：如果T是任意Java类型，T.class将代表匹配的类对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class cl1 &#x3D; Random.class;Class cl2 &#x3D; int.class;Class cl3 &#x3D; Double[].class;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虚拟机为每个类型管理一个Class对象，可以用==运算符实现两个类对象比较打的操作。</p><p><code>if(e.getClass() == Employee.class)</code></p><p>还有一个很有用的方法newInstance(),用来动态地创建一个类的实例。例如：</p><p><code>e.getClass().newInstance()</code></p><p>创建了一个与e相同类型的实例，newInstance方法调用类默认的构造器。</p><p>将forName和newInstance结合起来使用，根据存储在字符串中的类名动态创建一个对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String s &#x3D; &quot;java.util.Random&quot;;Object m &#x3D; Class.forName(s).newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-6-2-捕获异常"><a href="#5-6-2-捕获异常" class="headerlink" title="5.6.2 捕获异常"></a>5.6.2 捕获异常</h3><p>Class.forName可能抛出异常，编译器会要求提供一个处理器。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">try&#123;String name &#x3D; ...;&#x2F;&#x2F;get class nameClass c1 &#x3D; Class.forName(name);&#x2F;&#x2F;might throw exceptiondo something with c1;&#125;catch (Exception e)&#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-3-利用反射分析类的能力"><a href="#5-6-3-利用反射分析类的能力" class="headerlink" title="5.6.3 利用反射分析类的能力"></a>5.6.3 利用反射分析类的能力</h3><p>反射机制可以用来检查类的结构：</p><p>在java.lang.reflect包中有三个类Field、Method、Constructor分别用于描述类的域、方法、构造器。这三个类都有一个叫做getName的方法，用来返回项目的名称。</p><p>Field类有一个getType方法，用来返回描述域所属类型的Class对象。Method类有一个可以报告报告参数类型返回类型的方法，Constructor类有一个报告参数类型的方法。这三个类有一个getModifiers的方法，它返回一个整形数值，用不同的位开关描述public和static这样的修饰符使用状况。</p><p>利用java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整数数值，例如可以用isPublic、isPrivate、isFinal判断方法或构造器是否是public、private或final，还可以使用Modifier.toString方法将修饰符打印出来。</p><p>Class类中的getFields、getMethods、getConstructors方法返回类提供的public域、方法和构造器数组，其中包括超类的共有成员。getDeclareFields、getDeclareMethods、getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有和受保护的成员，但不包括超类的成员。</p><p>下面程序示例如何打印一个类的全部信息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package reflection;import java.util.*;import java.lang.reflect.*;public class ReflectionTest &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; TODO Auto-generated method stubString name;if(args.length &gt; 0) name &#x3D; args[0];else&#123;Scanner in &#x3D; new Scanner(System.in);System.out.println(&quot;Enter class name (e.g. java.util.Date): &quot;);name &#x3D; in.next();&#125;try &#123;Class c1 &#x3D; Class.forName(name);Class superc1 &#x3D; c1.getSuperclass();String modifiers &#x3D; Modifier.toString(c1.getModifiers());if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);System.out.print(&quot;class &quot; + name);if (superc1 !&#x3D; null &amp;&amp; superc1 !&#x3D; Object.class) System.out.print(&quot; extends &quot; + superc1.getName());System.out.print(&quot;\n&#123;\n&quot;);printConstructors(c1);System.out.println();printMethods(c1);System.out.println();printFields(c1);System.out.println(&quot;&#125;&quot;);&#125;catch (ClassNotFoundException e) &#123;e.printStackTrace();&#125;System.exit(0);&#125;public static void printConstructors(Class c1)&#123;Constructor[] constructors &#x3D; c1.getDeclaredConstructors();for (Constructor c : constructors)&#123;String name &#x3D; c.getName();System.out.print(&quot;  &quot;);String modifiers &#x3D; Modifier.toString(c.getModifiers());if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);System.out.print(name + &quot;(&quot;);Class[] paramTypes &#x3D; c.getParameterTypes();for(int j &#x3D; 0; j &lt; paramTypes.length; j++) &#123;if (j &gt; 0) System.out.print(&quot;, &quot;);System.out.print(paramTypes[j].getName());&#125;System.out.println(&quot;);&quot;);&#125;&#125;public static void printMethods(Class c1)&#123;Method[] methods &#x3D; c1.getDeclaredMethods();for (Method m : methods)&#123;Class retType &#x3D; m.getReturnType();String name &#x3D; m.getName();System.out.print(&quot;  &quot;);String modifiers &#x3D; Modifier.toString(m.getModifiers());if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;);Class[] paramTypes &#x3D; m.getParameterTypes();for (int j &#x3D; 0; j &lt; paramTypes.length; j++)&#123;if (j &gt; 0) System.out.print(&quot;, &quot;);System.out.print(paramTypes[j].getName());&#125;System.out.println(&quot;);&quot;);&#125;&#125;public static void printFields(Class c1)&#123;Field[] fields &#x3D; c1.getDeclaredFields();for(Field f:fields)&#123;Class type &#x3D; f.getType();String name &#x3D; f.getName();System.out.print(&quot;  &quot;);String modifiers &#x3D; Modifier.toString(f.getModifiers());if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);System.out.println(type.getName() + &quot; &quot; + name + &quot;;&quot;);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">APIjava.lang.ClassField[] getFields()Field[] getDeclaredFields()getFields方法返回一个包含Field对象的数组，这些对象记录了这个类或其超类的公有域。getDeclaredFields方法也将返回包含Field对象的数组，这些对象记录了这个类的全部域。Method[] getMethods()Method[] getDeclaredMethods()返回包含Method对象的数组：getMethods将返回所有的公有方法，包含从超类继承的共有方法；getDeclaredMethods返回这个类或接口的全部方法，但不包括由超类继承的方法。Constructor[] getConstructors()Constructor[] getDeclaredConstructors()返回包含Constructor对象的数组，其中包含了Class对象所描述的类的所有共有构造器(getConstructors)或所有构造器(getDeclaredConstructors);java.lang.reflect.Field&#x2F;Method&#x2F;ConstructorClass getDeclaringClass()返回一个用于描述类中定义的构造器、方法或域的Class对象。Class[] getExceptionTypes()(在Constructor和Method类中)返回一个用于描述方法抛出的异常类型的Class对象数组int getModifiers()返回一个用于描述构造器、方法或域的修饰符的整形数值。使用Modifier类中的这个方法可以分析这个返回值。String getName()返回一个用于描述构造器、方法或域名的字符串Class[] getParameterTypes()(在Constructor和Method类中)返回一个用于描述参数类型的Class对象数组。Class[] getReturnType()(在Method类中)返回一个用于描述返回类型的Class对象 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-4-在运行时使用反射分析对象"><a href="#5-6-4-在运行时使用反射分析对象" class="headerlink" title="5.6.4 在运行时使用反射分析对象"></a>5.6.4 在运行时使用反射分析对象</h3><p>上一节学习了如何查看任意对象的数据域名称和类型：</p><ul><li>获得对应的Class对象</li><li>通过Class对象调用getDeclaredFields</li></ul><p>利用反射机制还可以查看在编译时还不清楚的对象域。<br>查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个对象，其值为obj域的当前值。运行示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee harry &#x3D; new Employee(&quot;Harry Hacker&quot;, 35000, 10, 1, 1989);Class c1 &#x3D; harry.getClass();Field f &#x3D; c1.getDeclaredField(&quot;name&quot;);&#x2F;&#x2F; the name field of the Employee classObject v &#x3D; f.get(harry);&#x2F;&#x2F; the value of the name field of the harry object, i.e., the String object &quot;Harry Hacker&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，name是一个私有域，get方法受到访问权限的限制，需要调用Field、Method或Constructor对象的setAccessible方法。例如：</p><p><code>f.setAccessible(true);        //now OK to call f.get(harry)</code></p><p>注：setAccessible方法是AccessibleObject类中的一个方法，它是Field、Method、Constructor<br>类的公共超类。</p><p>get方法还存在一个问题：name域是一个String，因此将它作为Object返回没有什么问题，但是对于salary域，它属于double类型，double类型不是对象，反射机制将会自动把这个域值打包到相应的对象包装器中，这里将打包成Double。</p><p><code>f.set(obj, value)</code>可以将obj对象的f域设置成新值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">APIjava.lang.reflect.AccessibleObjectvoid setAccessible(boolean flag)boolean isAccessible()static void setAccessible(AccessibleObject[] array, boolean flag)java.lang.ClassField getField(String name)Field[] getField()Field getDeclaredField(String name)Field[] getDeclaredFields()java.lang.reflect.FieldObject get(Object obj)void set(Object obj, Object newValue)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-5-使用反射编写泛型数组代码"><a href="#5-6-5-使用反射编写泛型数组代码" class="headerlink" title="5.6.5 使用反射编写泛型数组代码"></a>5.6.5 使用反射编写泛型数组代码</h3><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static Object goodCopyOf(Object a, int newLength)&#123;Class c1 &#x3D; a.getClass();if (!c1.isArray()) return null;Class componentType &#x3D; c1.getComponentType();int length &#x3D; Array.getLength(a);Object newArray &#x3D; Array.newInstance(componentType, newLength);System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));return newArray;&#125;int[] a &#x3D; &#123;1, 2, 3, 4, 5&#125;;a &#x3D; (int[]) goodCopyOf(a, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-6-调用任意方法"><a href="#5-6-6-调用任意方法" class="headerlink" title="5.6.6 调用任意方法"></a>5.6.6 调用任意方法</h3><p>反射机制允许你调用任意方法</p><p>与Field类的get方法查看对象域的过程类似，Method类中有一个invoke方法，它允许调用包装在当前Method对象中的方法。</p><p><code>Object invoke(Object obj, Object...args)</code></p><p>第一个参数是隐式参数，其余的对象提供了显示参数。对于静态方法，第一个参数可以忽略。<br>例如，假设用m1代表Employee类的getName方法，下面这条语句演示了如何调用这个方法：</p><p><code>String n = (String) m1.invoke(harry);</code></p><p>可以由Class类中的getMethod方法得到一个Method对象，它与getField方法类似，但是可能存在同名的方法，因此，还必须提供想要的方法夫人参数类型。</p><p><code>Method getMethod(String name, Class... parameterTypes)</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Method m1 &#x3D; Employee.class.getMethod(&quot;getName&quot;);Method m2 &#x3D; Employee.class.getMethod(&quot;raiseSalary&quot;, double.class);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使得代码的执行速度更快，更易于维护。</p><h2 id="5-7-继承的设计技巧"><a href="#5-7-继承的设计技巧" class="headerlink" title="5.7 继承的设计技巧"></a>5.7 继承的设计技巧</h2><p>设计继承关系的建议：</p><ul><li>将公共操作和域放在超类</li><li>不要使用受保护的域</li><li>使用继承实现”is-a”关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>在覆盖方法时，不要改变预期的行为</li><li>使用多态，而非类型信息</li><li>不要过多地使用反射</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常学习</title>
      <link href="2020/121616109.html"/>
      <url>2020/121616109.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java异常学习"><a href="#Java异常学习" class="headerlink" title="Java异常学习"></a>Java异常学习</h1><h2 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    Scanner in &#x3D; new Scanner(System.in);    int[] a &#x3D; new int[10];  &#x2F;&#x2F;创建长度为10的一维数组    int idx;    idx &#x3D; in.nextInt();     &#x2F;&#x2F;由用户输入数组索引    try&#123;        a[idx] &#x3D; 10;        System.out.println(&quot;hello&quot;);    &#125;    catch (ArrayIndexOutOfBoundsException e) &#123;        System.out.println(&quot;caught&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码捕获ArrayIndexOutOfBoundsException异常，当用户输入idx值超过数组最大索引时，触发异常捕获，print(“hello”)部分将不会执行，输出”caught”。</p><h2 id="1-2基本代码格式"><a href="#1-2基本代码格式" class="headerlink" title="1.2基本代码格式"></a>1.2基本代码格式</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    &quot;代码块&quot;&#125;catch (exception1 e)&#123;    &quot;处理exception1异常的代码&quot;&#125;catch (exception2 e)&#123;    &quot;处理exception2异常的代码&quot;&#125;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-异常捕捉机制"><a href="#1-3-异常捕捉机制" class="headerlink" title="1.3 异常捕捉机制"></a>1.3 异常捕捉机制</h2><p><img src="/images/Exception.PNG" alt="异常捕获机制" title="Exception"></p><h2 id="1-4-捕获异常后如何处理"><a href="#1-4-捕获异常后如何处理" class="headerlink" title="1.4 捕获异常后如何处理"></a>1.4 捕获异常后如何处理</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">catch (exception e)&#123;    System.println(e.getMessage());    System.println(e);    e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体如何处理取决于业务逻辑需要<br>如果不需要在当前层面处理异常，则可以再次抛出，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">catch (exception e)&#123;    &quot;该层处理逻辑&quot;    throw e;    &#x2F;&#x2F;再次抛出异常，由下一层处理&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-示例"><a href="#1-5-示例" class="headerlink" title="1.5 示例"></a>1.5 示例</h2><p>读文件的步骤：</p><ol><li>打开文件</li><li>判断文件大小</li><li>分配内存</li><li>把文件内容读入内存</li><li>关闭文件<br>每一步依赖上一步的正常工作。<pre class="line-numbers language-java" data-language="java"><code class="language-java">try&#123;    open the file;    determine its size;    allocate that much memory;    read the file into memory;    close the file;&#125;catch(fileOpenFailed)&#123;    doSomething;&#125;catch(sizeDeterminationFailed)&#123;    doSomething;&#125;catch(memoryAllocationFailed)&#123;    doSomething;&#125;catch(readFailed)&#123;    doSomething;&#125;catch(fileCloseFailed)&#123;    doSomething;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>异常机制分开了业务逻辑和错误处理代码。</li></ol><h3 id="1-6-异常的抛出"><a href="#1-6-异常的抛出" class="headerlink" title="1.6 异常的抛出"></a>1.6 异常的抛出</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class OpenException extends Throwable&#123;  &#x2F;&#x2F;能抛出异常的类继承了Throwable类&#125;&#x2F;&#x2F;Exception类继承了Throwable类，自定义类也可以继承自Exception类。public static void readFile() throws OpenException&#123; &#x2F;&#x2F;如果函数可能抛出异常，则要添加throws    if(open() &#x3D;&#x3D; -1)&#123;               &#x2F;&#x2F;而对于想ArrayIndexOutOfBoundsException这样的异常是不用声明的        throw new OpenException();    &#125;&#125;public static void main(String[] args)&#123;    try&#123;        readFile();    &#125; catch(OpenException e)&#123;        ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-7-catch是怎么匹配异常的"><a href="#1-7-catch是怎么匹配异常的" class="headerlink" title="1.7 catch是怎么匹配异常的"></a>1.7 catch是怎么匹配异常的</h3><p>is-A的关系<br>抛出子类的异常能被捕获父类异常的catch捕捉到<br>因此<code>catch(Exception e)</code>可以捕捉任何异常</p><h3 id="1-8-异常遇到继承"><a href="#1-8-异常遇到继承" class="headerlink" title="1.8 异常遇到继承"></a>1.8 异常遇到继承</h3><ul><li><p>子类中成员函数不能抛出与父类同名的成员函数更多的异常，因为存在用一个父类类型管理子类对象的情况</p></li><li><p>子类的构造函数应包含父类构造函数抛出的异常，应为生成子类对象时会调用父类的构造函数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础语法</title>
      <link href="2020/121516108.html"/>
      <url>2020/121516108.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法教程"><a href="#Markdown语法教程" class="headerlink" title="Markdown语法教程"></a>Markdown语法教程</h1><h2 id="1-Markdown标题语法"><a href="#1-Markdown标题语法" class="headerlink" title="1.Markdown标题语法"></a>1.Markdown标题语法</h2><p>在单词或短语前添加#号，#的数量代表了标题的级别</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># here&#39;s is a heading<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="here’s-is-a-heading"><a href="#here’s-is-a-heading" class="headerlink" title="here’s is a heading"></a>here’s is a heading</h1><h2 id="2-Markdown段落语法"><a href="#2-Markdown段落语法" class="headerlink" title="2.Markdown段落语法"></a>2.Markdown段落语法</h2><p>使用空白行将一行或多行文本进行分隔  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">I really like using  Markdown.I think I&#39;ll use it to   format all of my  documents from now on.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>I really like using<br>Markdown.</p><p>I think I’ll use it to<br>format all of my<br>documents from now on.</p><h2 id="3-Markdown换行语法"><a href="#3-Markdown换行语法" class="headerlink" title="3.Markdown换行语法"></a>3.Markdown换行语法</h2><p>在一行的末尾添加两个或多个空格，然后按回车键，即可创建一个换行。<br><code>This is the first line.\s\s   And this is the second   line.\s\s</code></p><p>This is the first line.<br>And this is the second<br>line.  </p><h2 id="4-Markdown强调语法"><a href="#4-Markdown强调语法" class="headerlink" title="4.Markdown强调语法"></a>4.Markdown强调语法</h2><h3 id="粗体（bold）"><a href="#粗体（bold）" class="headerlink" title="粗体（bold）"></a>粗体（bold）</h3><p>要加粗文本，在单词或短语的前后各添加两个星号。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Love**is**bold<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Love<strong>is</strong>bold</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>在单词或短语前后添加一个星号或下划线  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Italicized text is the *cat&#39;s meow*.  Italicized text is the _cat&#39;s meow_.  A*cat*meow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Italicized text is the <em>cat’s meow</em>.<br>Italicized text is the <em>cat’s meow</em>.<br>A<em>cat</em>meow  </p><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><p>要同时用粗体和斜体突出显示文本，在单词或短语的前后各添加三个星号或下划线。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">This text is ***really important***.  This text is ___really important___.  This text is __*really important*__.  This text is **_really important_**.&#96;&#96;&#96; This text is ***really important***.  This text is ___really important___.  This text is __*really important*__.  This text is **_really important_**.  ## 5.Markdown引用语法要创建块引用，在段落前添加一个&gt;符号&#96;&#96;&#96;bash&gt; Dorothy followed her through many of the beautiful rooms in her castle.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><p>多个段落的块引用，为段落之间的空白行添加一个&gt;符号。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><p>嵌套块引用，在要嵌套的段落前添加一个&gt;&gt;符号。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt;The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<br>带有其他元素的块引用块引用可以包含其他Markdown格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p></blockquote></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - profits were higher than ever.&gt;&gt;  *Everything* is going according to **plan**.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h2 id="6-Markdown列表语法"><a href="#6-Markdown列表语法" class="headerlink" title="6.Markdown列表语法"></a>6.Markdown列表语法</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字1起始。<br>示例1</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1. first item2. Second item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>first item</li><li>Second item</li></ol><p>示例2  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1. First item2. Second item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>First item</li><li>Second item</li></ol><p>示例3</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1. First item2. Second item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>First item</li><li>Second item</li></ol><p>示例4</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1. First item2. Second item3. Third item    1. Indented item    2. Indented item4. Fourth item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>First item</li><li>Second item</li><li>Third item<ol><li>Indented item</li><li>Indented item</li></ol></li><li>Fourth item</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号（-）、星号（*）或加号（+）。缩进一个或多个列表项可创建嵌套列表。<br>示例1</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- First item- Second item- Third item- Fourth item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul><p>示例2</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* First item* Second item* Third item* Fourth item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul><p>示例3</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+ First item+ Second item+ Third item+ Fourth item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul><p>示例4</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- First item- Second item- Third item - Indented item - Indented item- Fourth item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ul><h3 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a>在列表中嵌套其他元素</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。</p><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* This is the first list item.* Here&#39;s the second list item.  I need to add another paragraph below the second list item.* And here&#39;s the third list item.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>  I need to add another paragraph below the   second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* This is the first list item.* Here&#39;s the second list item.    &gt; A blockquote would look great below the second list item.* And here&#39;s the third list item.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here’s the third list item.</p></li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.  Open the file.2.  Find the following code block on line 21:    &#96;&#96;&#96;bash        &lt;html&gt;            &lt;head&gt;            &lt;title&gt;Test&lt;&#x2F;title&gt;            &lt;&#x2F;head&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li> Update the title to match the name of your website.<pre class="line-numbers language-none"><code class="language-none">1.  Open the file.2.  Find the following code block on line 21:        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;Test&lt;&#x2F;title&gt;          &lt;&#x2F;head&gt;3.  Update the title to match the name of your website.## 7.Markdown代码语法要将单词或短语表示为代码，请将其包裹在反引号中。  &#96;&#96;&#96;bashAt the command prompt,type &#96;nano&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>At the command prompt,<br>type <code>nano</code></li></ol><h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号中。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#96;&#96;Use &#96;code&#96; in  your  Markdown file.&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>Use `code` in  your   Markdown file.</code></p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;html&gt; &lt;head&gt; &lt;&#x2F;head&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;html&gt; &lt;head&gt; &lt;&#x2F;head&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-Markdown分隔线语法"><a href="#8-Markdown分隔线语法" class="headerlink" title="8.Markdown分隔线语法"></a>8.Markdown分隔线语法</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号（***）、破折号（—）或下划线（___）,并且不能包含其他内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Try to put a blank line before...***...and after a horizontal rule.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Try to put a blank line before…</p><hr><p>…and after a horizontal rule.</p><h2 id="9-Markdown链接语法"><a href="#9-Markdown链接语法" class="headerlink" title="9.Markdown链接语法"></a>9.Markdown链接语法</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<br>超链接Markdown语法代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[超链接显示名](超链接地址 “超链接title”)这是一个链接[Markdown语法](https:&#x2F;&#x2F;markdown.com.cn)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是一个链接<a href="https://markdown.com.cn/">Markdown语法</a>。</p><h3 id="给链接增加Title"><a href="#给链接增加Title" class="headerlink" title="给链接增加Title"></a>给链接增加Title</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">这是一个链接 [Markdown语法](https:&#x2F;&#x2F;markdown.com.cn &quot;最好的markdown教程&quot;)。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><h3 id="网址和Email地址"><a href="#网址和Email地址" class="headerlink" title="网址和Email地址"></a>网址和Email地址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;https:&#x2F;&#x2F;markdown.com.cn&gt;&lt;fake@example.com&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://markdown.com.cn/">https://markdown.com.cn</a><br><a href="mailto:&#x66;&#x61;&#x6b;&#x65;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#x66;&#x61;&#x6b;&#x65;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a></p><h3 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h3><p>强调链接，在链接语法前后增加星号。要将链接表示为代码，请在方括号中添加反引号。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">I love supporting the **[EFF](https:&#x2F;&#x2F;eff.org)**.This is the *[Markdown Guide](https:&#x2F;&#x2F;www.markdownguide.org)*.See the section on [&#96;code&#96;](#code).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em>.<br>See the section on <a href="#code"><code>code</code></a>.</p><h3 id="引用类型链接"><a href="#引用类型链接" class="headerlink" title="引用类型链接"></a>引用类型链接</h3><p>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。</p><h4 id="链接的第一部分格式"><a href="#链接的第一部分格式" class="headerlink" title="链接的第一部分格式"></a>链接的第一部分格式</h4><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母、数字、空格或标点符号。</p><p>以下示例格式对于链接的第一部分效果相同：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[hobbit-hole][1][hobbit-hole] [1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>链接的第二部分格式<br>引用类型链接的第二部分使用以下属性设置格式：<br>1.放在括号中的标签，其后紧跟一个冒号和至少一个空格(例如<code>[label]:</code>)。<br>2.链接的URL，可以选择将其括在尖括号中。<br>3.链接的可选标题，可以将其括在双引号中，单引号或括号中。</p><p>以下示例格式对于链接的第二部分效果相同：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[1]: https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle[1]: https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;[1]: https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle &#39;Hobbit lifestyles&#39;[1]: https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle (Hobbit lifestyles)[1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;[1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39;[1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; (Hobbit lifestyles)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾(例如尾注或脚注)。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[hobbit-hole][1][1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; (Hobbit lifestyles)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle" title="Hobbit lifestyles">hobbit-hole</a></p><h2 id="10-Markdown图片语法"><a href="#10-Markdown图片语法" class="headerlink" title="10.Markdown图片语法"></a>10.Markdown图片语法</h2><p>要添加图像，请使用感叹号(<code>!</code>)，然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：<code>![图片alt](图片链接&quot;图片title&quot;)</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">![这是蒲公英图片](&#x2F;images&#x2F;flower.jpg &quot;Magic Gardens&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/flower.jpg" alt="这是蒲公英图片" title="Magic Gardens"></p><p>给图片增加链接，请将图像的Markdown括在方括号中，然后将链接添加在圆括号中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[![宠物猫](&#x2F;images&#x2F;cat.jpg &quot;Shiprock&quot;)](https:&#x2F;&#x2F;markdown.com.cn)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://markdown.com.cn/"><img src="/images/cat.jpg" alt="宠物猫" title="Shiprock"></a></p><h2 id="11-Markdown转义字符语法"><a href="#11-Markdown转义字符语法" class="headerlink" title="11.Markdown转义字符语法"></a>11.Markdown转义字符语法</h2><p>要显示原本用于格式化Markdown文档的字符，请在字符前面添加反斜杠字符。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">\* Without the backslash, this would be a bullet in an unordered list.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>* Without the backslash, this would be a bullet in an unordered list.</p><h3 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p><table><thead><tr><th align="center">Character</th><th align="left">Name</th></tr></thead><tbody><tr><td align="center">\</td><td align="left">backslash</td></tr><tr><td align="center">`</td><td align="left">backtick</td></tr><tr><td align="center">*</td><td align="left">asterisk</td></tr><tr><td align="center">_</td><td align="left">underscore</td></tr><tr><td align="center">{}</td><td align="left">curly braces</td></tr><tr><td align="center">[]</td><td align="left">brackets</td></tr><tr><td align="center">()</td><td align="left">parentheses</td></tr><tr><td align="center">#</td><td align="left">pound sign</td></tr><tr><td align="center">+</td><td align="left">plus sign</td></tr><tr><td align="center">-</td><td align="left">minus sign (hyphen)</td></tr><tr><td align="center">.</td><td align="left">dot</td></tr><tr><td align="center">!</td><td align="left">exclamation mark</td></tr><tr><td align="center">|</td><td align="left">pipe</td></tr></tbody></table><h2 id="12-Markdown内嵌HTML标签"><a href="#12-Markdown内嵌HTML标签" class="headerlink" title="12.Markdown内嵌HTML标签"></a>12.Markdown内嵌HTML标签</h2><p>对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可。</p><h3 id="行级内联标签"><a href="#行级内联标签" class="headerlink" title="行级内联标签"></a>行级内联标签</h3><p>HTML的行级内联标签如<code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code>不受限制，可以在Markdown的段落、列表或是标题里任意使用。按照个人习惯，甚至可以不用Markdown格式，而采用HTML标签来格式化。例如：如果比较喜欢HTML的<code>&lt;a&gt;</code>或<code>&lt;img&gt;</code>标签，可以直接使用这些标签，而不用Markdown提供的链接或是图片语法。当需要更改元素的属性时，使用HTML标签更方便些。</p><p>HTML行级内联标签和区块标签不同，在内联标签的范围内，Markdown的语法是可以解析的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">This **word** is bold. This &lt;em&gt;word&lt;&#x2F;em&gt; is italic.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This <strong>word</strong> is bold. This <em>word</em> is italic.</p><h3 id="区块标签"><a href="#区块标签" class="headerlink" title="区块标签"></a>区块标签</h3><p>区块元素——比如<code>&lt;div&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code>等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用tab或是空白来缩进。<br>Markdown会自动识别这区块元素，避免在区块标签前后加上没有必要的<code>&lt;p&gt;</code>标签。</p><p>例如，在Markdown文件里加上一段HTML表格：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">This is a regular paragraph.&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;Foo&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;This is another regular paragraph.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>This is a regular paragraph.</p><table>    <tr>        <td>Foo</td>    </tr></table><p>This is another regular paragraph.</p><p>请注意，Markdown语法在HTML区块标签中将不会被进行处理。例如，你无法在HTML区块内使用Markdown形式的<em>强调</em>。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/121216107.html"/>
      <url>2020/121216107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
